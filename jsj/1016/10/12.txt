多线程编程 之 互斥和同步；

互斥 ===》互斥锁 ===》pthread_mutex_t 

使用操作框架：
  创建互斥锁 ===》初始化互斥锁 ====》加锁、解锁 ===》销毁互斥锁；


1、创建互斥锁：使用互斥锁类型定义一个全局变量；
	 pthread_mutex_t   mutex;

2、初始化互斥锁：pthread_mutex_init
  int pthread_mutex_init(pthread_mutex_t *mutex,
                const pthread_mutexattr_t *attr);
  功能：该函数用于互斥锁的默认初始化，将锁的默认属性生效；
  参数：mutex  要初始化的目标互斥锁
	    atrr   要初始化的互斥锁属性值，一般NULL表示默认属性；
  返回值：成功 0
		  失败 -1；

  注意：一般在线程创建之前就要初始化互斥锁；

3、加锁：
int pthread_mutex_lock(pthread_mutex_t *mutex);
功能：该函数可以将某个区域的代码执行加锁操作
      保证该部分代码的排他性访问；

参数： mutex  要加锁的互斥锁

返回值：0 成功  进程将会执行该行代码以后的其他语句
		-1 失败  不会返回，会继续在该行代码位置阻塞等待解锁；

  解锁：
  int pthread_mutex_unlock(pthread_mutex_t *mutex);
  功能：该函数的操作与加锁操作功能相反，用于已经加锁的
	    互斥锁进行解锁操作；
  参数：mutex 要解锁的互斥锁
  返回值：成功  0  互斥锁解锁
		  失败  -1

注意：加锁和解锁的目标对象针对的是代码行；
      加锁==解锁之间的代码属于原子操作；

练习题：
	使用互斥锁和多线程完成如下功能，
	线程1 依次输出10 以内偶数
	线程2 依次输出10 以内奇数

问题：
	1、如果两个线程在操作过程中，一个线程没有加锁操作；
	   那么临界资源能不能访问？

	2、如果加锁的位置和解锁的位置位于循环代码内部，是否
	   可能出现加锁无效的情况，原线程继续抢锁执行？

	3、互斥锁只能是全局变量码？能不能栈区或者堆区变量？
	   怎么用？


		可以使用，数据访问乱序。

		单核cpu运行会和锁在循环之外相同效果。
		多核cpu运行可能出现互相抢锁执行。

		只要不被释放并可以将地址传给子线程就可用；



销毁互斥锁：
 int pthread_mutex_destroy(pthread_mutex_t *mutex);
 功能：该函数用于互斥锁的销毁操作，目的是在使用互斥锁
       的时候需要重新初始化；
 参数： mutex 互斥锁；
 返回值：成功 0
		失败  -1；


非阻塞加锁：
 int pthread_mutex_trylock(pthread_mutex_t *mutex);
 功能：函数功能完全类似于pthread_mutex_lock ,唯一区别就是
	   不阻塞。
 参数： mutex 互斥锁
 返回值：成功 0  表示加锁成功，但没有阻塞；
		 失败 -1 表示加锁失败，不能加锁；


练习题：
	设计一组函数，可以模拟实现互斥锁的功能。

===============================================================
互斥锁存在的问题：不能指定执行线程的次序，有可能出现抢锁执行现象；

信号量机制：======》判断是否具有可用资源；
            =====》可用资源 == 信号 == 信号量值为1 的信号；

linux 线程的信号量 简称 二值信号量 === 信号量的值（0，1）

信号量的使用框架：
 创建信号量 ===》初始化信号量 ==》 PV操作  ====》信号量的销毁；

0、头文件：#include <semaphore.h>

1、创建信号量 ： 全局定义一个 sem_t 类型的变量；

2、初始化： 
int sem_init(sem_t *sem, int pshared, unsigned int value);
功能： 该函数可以用于信号量的初始化工作；
参数： sem 要初始化的目标信号量地址；
	   pshared 信号量的控制标记，0 表示线程使用，非0 进程使用；
	   value   信号量的初始值，0 表示没有资源，1 表示有可用资源；

返回值：成功 0
		失败 -1；

注意：该函数调用一般位于线程创建之前；



3、信号量的pv操作：
	p 操作： 申请资源 ==》sem_wait()
	v 操作： 释放资源 ==》sem_post()
	p 操作：
	int sem_wait(sem_t *sem);
	功能：该函数可以判断指定信号的信号量值，如果该值为0 
	      则进程阻塞等待，如果该值为1 则继续执行，并将
		  该信号量值减1操作；

	参数：sem 信号量
	返回值：成功 0
			失败 -1；
	v 操作：
	int sem_post(sem_t *sem);
	功能：该函数可以将执行的信号量进行释放资源的操作，即
		  函数执行不会阻塞但一定会进行 sem = sem + 1 操作；
	
	参数：sem 信号量
	返回值：成功 0
			失败 -1；

练习：
	设计一个多线程程序，至少有3个子线程，每个线程输出不同的
	语句，要求程序运行的时候执行 2 1 3 的次序展示每个线程的
	输出，要求用信号量实现；
	
思考题：
	信号量的值能不能一直进行sem_post操作，信号量值会不会>1?
	能不能一直进行sem_wait操作，获取多次资源？

获取资源个数： int sem_getvalue(sem_t *sem, int *sval);
功能：该函数可以用于获取指定信号的信号量值。
参数：sem 要获取其值的信号量
	  sval 信号量的当前值；
返回值：成功 0
		失败 -1；


面试题要求：
1、该部分代码要验证什么问题？
	临界资源value1 value2 在有互斥锁和没互斥锁情况下的排序性访问；


2、该部分代码中 _LOCK_ 是什么？起到什么作用
	用户自定义的宏  ，作用是 条件编译；

3、代码中有几个线程在执行？分别是谁？
		2 个线程执行，分别是主线程和子线程；

4、代码执行的结果是什么？能否改进？
	子线程的printf语句将会打印输出count value1 value2的不同/相同值
	改进方案： 增加 _LOCK_ 宏定义，使互斥锁生效，不在输出语句；


	
信号量的销毁：
 int sem_destroy(sem_t *sem);
 功能：该函数可以销毁指定信号量；
 参数：sem 要销毁的信号量
 返回值：成功 0
		 失败 -1；


信号量的非阻塞申请资源：
 int sem_trywait(sem_t *sem);
 功能：该函数可以用于非阻塞方式获取信号量的资源
 参数：sem 要获取资源的信号量
 返回值：成功 0  表示已经获取资源
		 失败 -1 表示没有可用资源，但是不会阻塞。


================================================================
gdb 调试多进程和多线程：

注意：默认情况下gdb 跟踪多进程和多线程的时候
	  只跟踪主进程和主线程不能直接跟踪子进程/子线程；

1、gdb跟踪子进程：
	在编译阶段要加入 -g  允许目标代码调试；
	在fork函数之前修改执行方式：
		set follow-fork-mode child   表示接下来跟踪子进程
		set follow-fork-mode parent  表示接下来跟踪父进程


2、gdb跟踪子线程：
	在编译阶段要加入 -g 可调试
	要将线程创建函数执行完毕；
	使用 info threads 查看目前即将运行的目标线程信息
	  id号表示线程的任务号，如果要切入某个线程则使用
	  thread xx ===>xx 就是任务号


作业：
  使用信号量或者互斥锁设计一个模拟火车票售票系统，
  要求有100张火车票，有若干个售票窗口，每个窗口都可以
  买票，但是不能重复买票，要求将100 张火车票均匀的从
  这些窗口中卖出。

  ===》有全局变量n = 100;
  设计多个子线程，每个子线程都将n设为临界资源进行 -- 操作
  每个线程执行一次-- 操作就释放给其他线程 -- 操作；








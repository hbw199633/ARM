多进程控制：

1、进程的结束：
	1.1 return 关键字：只能在main函数中结束进程。
	1.2 exit（）
	#include <stdlib.h>
	void exit(int status);
	功能：使进程正常终止
	参数：status 程序正常结束时候的返回值，如果不返回
	      数据用0 表示。
	返回值：无

	如果父进程一直存在，子进程退出 ===》ps aux 
								   ===》僵尸进程
	如果子进程一直存在，父进程退出 ===》ps -ef
								   ===》孤儿进程

	1.3 _exit()
	#include <unistd.h>

	void _exit(int status);
	功能：该函数是系统调用接口函数可以使进程正常终止。
	参数：status 进程结束时候的返回值
	返回值：无


2、退出遇到的问题：
	2.1 退出状态 《==== return x； exit(y); _exit(z);
	2.2 僵尸进程 《=== 子进程退出，资源没有回收。

	wait()/waitpid()

	pid_t wait(int *status);
	功能：该函数具有阻塞等待回收子进程功能。
	参数：status 整形地址用于回收子进程的返回状态。
		  如果不关心返回值，用NULL表示。
		  一次wait只能回收一个子进程
		  wait回收没有优先级，先结束的先接收。
	返回值：成功  回收的子进程pid号
			失败  -1；
	注意：该函数一般用于创建者进程调用。

	printf("%d \n", WEXITSTATUS(status));

	status == num ===>num的含义必须事先约定。

思考题：
1、子进程退出时候能不能直接返回字符串信息，而不是数字编号。

	1.1 事先约定错误码表，范围 0 - 255 其中132 以下同步系统错误
		132 - 255 属于自定义错误。
	1.2 事先约定错误记录文件，返回值 0 表示无错 非0 表示有错
		错误信息自动记录到错误记录文件

	以上处理方式实在尚未解决进程间通信的前提下。

2、如果有多个子进程同时被创建，能不能指定只回收某个中间子进程?
	2.1 将不要回收的子进程，推后退出，先退出要回收的子进程。
	其他要指定回收只能使用 waitpid()

3、如果有多个子进程同时被创建，能不能子进程回收子进程？
   父进程能不能回收孙进程？

   平级之间不能互相回收，wait无法阻塞回收。
   父进程不能隔代回收孙子进程，只能回收自己的子进程。


指定回收子进程：
pid_t waitpid(pid_t pid, int *status, int options);
功能：该函数可以指定回收指定的子进程退出状态和信息。
参数：pid  >0  要回收的目标子进程pid
	  pid  = 0 相同组的子进程
	  pid  = -1 任意子进程，等价于 wait()
	  pid  < -1 回收pid绝对值等于组id的子进程
	
	  status 子进程的返回值
	  options 回收方式，0 表示阻塞回收
						WNOHANG 非阻塞回收
	   
返回值：成功 回收的子进程pid
        失败 -1；

wait和waitpid 区别： 阻塞  指定pid

=============================================================
多进程并发编程框架：
   fork() ===> exit() ====>wait();

多进程fork函数的主要用途：

1、守护进程

2、exec家族函数



守护进程的特征：
1、ps aux ===>STAT列 必须有s的组长标记
2、ps aux ===>TTY列  必须是?的终端类型
3、ps -ef ===>ppid列 必须是1的孤儿进程
以上三个规则必须同时满足才是真正的守护进程 ===》daemon进程

编写守护进程的步骤：5 步

创建孤儿进程 ===》修改成会话组长 ===》切换工作目录 
 ===》提权 ===》关闭文件描述符


 1、创建孤儿进程：
	  fork() ===>父进程exit()


2、会话组长
pid_t setsid(void);
功能：修改当前进程为会话组长。
参数：无
返回值：组长id

3、切换工作目录
 int chdir(const char *path);
 功能：将当前进程的工作目录调整为目标路径
 参数：path要切换到的工作目录，目的防止异常卸载。
 返回值：成功 0
		 失败 -1；

4、提权
mode_t umask(mode_t mask);
功能：该函数可以将当前进程的创建文件权限修改。
参数：mask要修改权限，该值在守护进程中要修改为0
返回值：新的文件操作权限。
		失败 -1；
		

5、关闭文件描述符 close()
   ====》getdtablesize()
   int getdtablesize(void);
   功能：获取当前进程能打开的最大文件描述符


练习题：
1、自己将守护进程过程封装成函数，并在main中调用
   实现自己的守护进程程序。


2、编写守护进程，每隔3秒向工作目录下新建一个普通
   文本文件。


作业：
	设计一个守护进程，完成如下功能：
	1、守护进程要后台随机启动
	2、守护进程要监控指定目录中文件是否有变化
	3、将有变化文件的名称和时间记录日志

















	

	


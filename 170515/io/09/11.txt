多线程编程之 互斥与同步：

互斥 ===》排他性访问：
原因：在多线程中可能出现临界资源的竞争问题；
解决方案： 设计一个机制保证临界资源的排他性访问；

在posix框架中有一个互斥锁，可以完成如上排他性访问；

互斥锁： ===》pthread内部自带的函数：
使用框架：
	创建互斥锁==》互斥锁的初始化==》加锁/解锁 ===》销毁互斥锁


1、创建互斥锁：
	pthread_mutex_t  定义一个全局互斥锁变量；

2、互斥锁初始化：
int pthread_mutex_init(pthread_mutex_t *mutex,
                       pthread_mutexattr_t *attr);

功能：该函数可以对指定的互斥锁进行默认值设置。
参数：mutex 要初始化的目标互斥锁地址
	  attr 要初始化的目标互斥锁属性，用NULL表示默认属性。
返回值：成功 0
		失败 -1；

如果不愿用函数初始化则用以下宏初始化：
 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;


3、互斥锁的加锁和解锁：
	加锁：int pthread_mutex_lock(pthread_mutex_t *mutex);
	功能：该函数可以用于临界资源的加锁操作保证排他性访问。
		  在使用该加锁操作过程中，lock和unlock 必须匹配
		  出现，否则可能出现死锁。
		  加锁开始到解锁结束的代码段属于原子操作。
		  一旦加锁成功，其他加锁操作将会在函数位置阻塞等待。
	参数：mutex 保护临界资源的互斥锁
	返回值：成功 0
			失败 -1；

	解锁：int pthread_mutex_unlock(pthread_mutex_t *mutex);
	功能：该函数可以用于之前已经加锁的互斥锁进行解锁操作。
		  一旦解锁该互斥锁可以被其他线程再次加锁使用，在没有
		  解锁之前该互斥锁不能使用。
	参数：mutex 保护临界资源的互斥锁
	返回值： 成功  0
			 失败  -1；

练习题：
	使用互斥锁，完成两个线程的控制，要求线程1依次输出10以内的
	偶数，线程2 依次输出10以内的奇数。

问题：
1、如果两个线程在操作过程中，一个线程没有加锁操作，那么临界
   资源能不能访问？===>能访问

   互斥锁应该怎么加：加锁操作控制的是代码段的唯一访问。

2、如果加锁位置在循环内部，会不会出现反复加锁无效的情况？
	单核的时候，循环内部与循环外部一样都会加锁有效
	多核的时候，互斥锁可能会出现随机抢锁情况。
	互斥锁的加锁解锁操作一定要考虑CPU核的情况。

3、互斥锁变量只能是全局变量吗？能不能是栈区或者堆区变量。
	3.1 在main中定义栈区或堆区互斥锁将互斥锁地址传参给子线程。
	3.2 先定义全局地址指针，在任意子线程中创建线程并给全局指针
		变量赋值，在其他子线程中使用该全局指针指向的互斥锁。

4、如何自己封装一组函数模拟实现互斥锁功能？


互斥锁的销毁：
 int pthread_mutex_destroy(pthread_mutex_t *mutex);
 功能：该函数可以将指定的已经创建的互斥锁销毁，已经
	   销毁的互斥锁不能直接使用，如果要用必须重新初始化
	   否则互斥锁的值不确定。

  参数：mutex 要销毁的互斥锁地址
  返回值：成功 0
		  失败 -1；

非阻塞互斥锁：
int pthread_mutex_trylock(pthread_mutex_t *mutex);
功能：非阻塞方式的加锁操作，所有功能类似与pthread_mutex_lock函数
	  唯一区别就是不阻塞等待。
参数：mutex 要加锁的互斥锁地址
返回值：成功 0  表示可以加锁并加锁成功
		失败 非0 表示不能加锁，加锁操作失败。

面试题2：
	1、该部分代码要验证什么问题

	2、该部分代码的_LOCK_ 是什么？起到什么作用

	3、代码中有几个线程在执行？分别是谁？

	4、代码执行的结果是什么？能否改进？


================================================================
使用互斥锁问题： 没有次序  ==》第一次资源访问会竞争。

需要设计一种机制既能保证排他性访问，又能有一定的次序。

linux 引入了信号量机制保证以上过程：

linux线程的信号量又称为 信号灯 ===》二值数字(1\0)

信号量的使用框架：
  创建信号量 ==》信号量初始化 ==》PV操作===》信号量的销毁

0、头文件；
	#include <semaphore.h>


1、创建信号量:使用信号量类型的数据定义一个信号量变量。

	sem_t  sem;

2、信号量的初始化

int sem_init(sem_t *sem, int pshared, unsigned int value);
功能：该函数可以将已经定义的信号量进行初始值设置。
参数：sem 要初始化的信号量地址
	  pshared 信号量使用控制，0 线程使用  非0 进程使用。
	  value 要初始化的信号量初始值，
			0 值则信号量默认会阻塞等待
			1 值则信号量可以继续运行
返回值：成功 0
		失败 -1；

3、信号量的PV操作：
	P 操作：申请资源操作
	int sem_wait(sem_t *sem);
	功能：该函数可以用于检测指定信号量是否有资源可用。
	      如果目标sem 有资源，则代码继续执行并进行sem = sem -1操作
		  如果目标sem 没有资源，则代码在该函数位置阻塞等待。
	参数：sem 要检测的目标信号量地址
	返回值：成功 0
			失败 -1；


	V 操作：释放资源操作
	int sem_post(sem_t *sem);
	功能：该函数可以用于指定信号量的释放资源操作，并会自动
		  执行 sem= sem+1操作。
	参数：sem 要释放资源的目标信号量
	返回值：成功 0
			失败 -1；


练习：
	使用信号量控制方式，完成互斥锁的10以内奇偶数输出的练习。
	要求10个数字间隔输出，线程1 每次打印奇数
						  线程2 每次打印偶数
	同时：必须保证线程1先执行，后线程2 执行，交替输出。
	

问题：
1、信号量的值能不能一直执行sem_post进行增加资源的操作？
	sem_wait能不能一直从多个资源中多次申请到资源。
	
	可以多次post和多次wait，只要sem中有资源，则p操作不会阻塞。


2、如果超过三个线程的子线程同时存在，如何约定他们之间的
   执行次序。
   首先在主线程中约定第一个执行线程，然后依次post指定的下一个
   线程。


销毁信号量：
int sem_destroy(sem_t *sem);
功能：该函数可以指定销毁某个信号量，如果要继续使用该信号量
      必须重新初始化，否则信号量值不确定。

参数：sem 要销毁的目标信号量地址

返回值：成功 0
		失败  -1；

非阻塞方式申请信号量：
int sem_trywait(sem_t *sem);
功能：该函数可以在申请信号的时候，立即返回而不阻塞。
参数：sem 要申请资源的信号量
返回值：成功 如果申请到信号量则返回 0
		失败 没有申请到信号量，返回非0 值；


面试题：
	设计一个程序，必须使用最少信号量实现，要求如下：
	一个线程用于获取用户输入信息，并存储到指定内存
	一个线程用户统计用户输入的信息长度，并打印输出字符个数；
	当用户输入“"quit" 的时候，程序退出。
	尽量少用多个信号量，少用多个线程实现如上要求：


作业：
1、使用互斥锁或者信号量完成昨天作业的第一题；


2 、设计一个多线程程序，可以将指定的某个文件分割成
	独立前缀的多个文件。
	比如：
		./a.out  xxx.iso 

		xxx_1
		xxx_2
		xxx_3
		...
	再设计另一个多线程程序，可以将指定前缀的文件合并
	称为原来的文件。
		./a.out  xxx

	要求：分解的文件合并还原之后的md5校验值一致。














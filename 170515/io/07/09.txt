多进程的主要应用： 
exec家族函数 ==>用来启动执行其他程序。

头文件：unistd.h

int execl(const char *path, const char *arg, ...);
功能：该函数可以用于启动一个指定路径下的目标程序。
参数：path 要启动的程序路径+名称，一般是绝对路径
	  arg  启动程序的名称和选项
	  ...  可变长参数，是启动程序的参数列表,参数
		   最后必须以NULL结尾。

返回值：成功 不能立即返回，目标程序启动将会完全占用
			 当前进程的所有内存空间为自己所用。

		失败 返回-1,并设置错误码

练习：
	使用fork创建一个子进程，并使用子进程执行ls程序
	并在父进程中对子进程的返回状态回收资源并打印输出。

	目标程序执行成功，子进程exit将不会执行，子进程的返回值
	有目标程序来决定，可以通过 echo $? 在终端中查看和父进程
	中对比确认。

	目标程序执行失败，子进程一定要exit退出，否则可能向后不可
	控执行。子进程的返回值有当前子进程自定义返回。父进程wait
	可以直接获取。

注意：所有exec家族函数中有l符号的家族函数，表示要将所有该程序
     的参数和选项都依次list出到当前函数的参数列表中，并以','隔开，
	 并位于程序名称和NULL之间。

思考题：
	修改以上练习题，自己编写一个测试程序，可以进行多个参数的主函数
	传参数调用，并编译成独立程序。 ===》./b.out xx  xx  xx

	在以上练习代码中fork子进程调用该程序实现自定义程序的启动。
	./a.out ==>fork ==>子进程要启动b.out



int execl(const char *path, const char *arg, ...);
int main(int argc,char *argv[])

int execv(const char *path, char *const argv[]);
功能：该函数功能类似与execl可以启动指定路径下的可执行程序并运行。
参数：path 要启动的目标程序路径+ 名称，一般用绝对路径
	  argv[] 启动的目标程序所需要的程序名称以及参数、选项 字符串
			 数组。
返回值：成功  不会返回，空间由目标进程占用
		失败  -1，并设置错误码


所有exec家族函数名称中如果有v符号，则执行程序的参数可以存储
在一个数组一样的容器(vector)中。


练习：
	将execl的练习部分使用execv重新实现一遍。

思考题目：
1、在执行execv启动其他程序的时候能不能通过main函数方式将
   main函数的参数2 传给execv的参数2 ？

   可以将main的参数直接传给execv执行

2、如果子进程启动的目标程序一直处于运行状态，如何通过父进程结束
   子进程，比如启动的程序是 top 的时候。


int execlp(const char *file, const char *arg, ...);
功能：该函数可以将启动指定程序并运行。
参数：file 要启动的目标程序名称，不需要路径，但是该程序
	  必须位于系统环境的PATH路径所在范围内 .
	  arg 要启动的目标程序名称，起到占位作用。
	  ... 可变长的目标程序参数和选项。
返回值：成功 不会返回，类似execl和execv的成功
		失败 -1

注意：execlp 的字符p的作用就是参数1 一定是progream的名称


int execvp(const char *file, char *const argv[]);
功能：该函数可以启动指定程序并运行。
参数：file要启动的目标程序名称，应该位于系统环境变量PATH范围内。
	  argv[] 要启动的目标程序的参数、选项数组，类似与execv形式
返回值：成功  不会返回
		失败  -1；


总结：如果要用exec家族函数启动系统程序，则使用带p字符的函数。
      如果要启动其他非系统安装的程序，则使用不带p字符的函数。

	  execl   execvp

===============================================================
练习：
1、面试题：使用任意的exec家族函数，自己封装一个函数
		   可以实现类似system()的效果。
		   system("ls"); ===>终端ls效果
		   system("ls -l"); ===>终端ls -l效果
		   system("touch a"); ===>终端 touch a 效果


2、任意选择exec家族函数实现一个自己的shell命令解释器。
   程序启动后，要有自己的命令提示符，并可以解释执行
   简单的命令。比如;
   ./a.out 

   console>>
   console>>
   console>> ls
   09.txt  abc2   creat_test.c  execlp.c  execv.c   x.c
   abc     a.out  execl.c       execv2.c  execvp.c
   console>>




gdb 调试多进程和多线程：

1、多进程调试：
	在gdb之前的gcc 编译阶段加 -g 选项，允许调试。
		gcc xxx.c -g

	在gdb开始调试后：在fork函数调用之前加入断点；
		gdb a.out 
		b  18
		r 

	如果即将执行fork函数，则选择如下方式：
	  set follow-fork-mode  [child/parent];
	默认自动跟踪 parent进程。

2、多线程调试：
	在gdb之前的gcc 阶段加入 -g 选项，允许调试。

	在线程开始之前加入断点。
	要先执行语句将线程创建出来。
	线程创建后用 info threads 查看正在执行的线程信息
	用thread id 来跟踪到目标线程中。
	可以在多个线程之间来回切换。

	默认情况下跟踪的是主线程。


==========================================================
进程间通信：

原因：目前没有一个直接可以完成多进程之间的数据共享的方案。

进程间通信机制：

1、古老的通信方式
		无名管道  有名管道  信号

2、IPC通信方式
		消息队列  共享内存  信号量集

3、SOCKET通信方式
		TCP    UDP 

古老通信方式中：信号 唯一异步通信方式
所有进程间通信： 共享内存 效率最高

古老通信方式：

管道：====》无名 管道没有名称，但是可以使用，基于内存
			有名 管道有名称，可以使用，基于文件系统

管道的共性：
1、框架：
	创建管道 ==》打开管道 ==》读写管道 ===》关闭管道 ==》销毁管道

2、工作模式： 半双工模式  《 单工
						  《 全双工

3、读写方式： 管道是设备文件，必须使用文件IO读写。


无名管道：
1、没有名称，基于内存；
2、只能用于有亲缘关系的进程间使用；
3、必须要在fork之前创建；

创建无名管道：pipe  ===>PIPE

#include <unistd.h>

int pipe(int fd[2]);
功能：该函数可以创建并打开一个无名管道。
参数： int 类型的数组，有两个元素。
	   fd[0]  ===>固定的管道读端
	   fd[1]  ===>固定的管道写端
	   注意：在使用该函数之前要定义该数组变量。
返回值：成功 0
		失败 -1；

读写管道：
read（）
write（）；

关闭管道：由于管道是一个文件描述符类型的设备
close();
===>close(fd[0]);
	close(fd[1]);

销毁管道： int 形式的数组作用域结束则自动销毁。

练习：
1、使用pipe建立管道，完成父子进程间结构体数据的传送。


思考题：
1、父子进程中pipe后是否都有 fd[0] fd[1]? 他们的值是多少 ？
   能不能直接操作？

   fd[0]/fd[1] ==>基于内存的文件描述符
   在单进程中也可以直接读写该文件，注意要先写后读

2、管道中存储的数据是什么形式，读完第一次还能不能读第二次？
	类似队列，先进先出，数据读后就没有了。

3、管道中最多能存储多少字节数据？===》管道的容量
	65535 字节  ===》64k 《=== 4k== 512*8
	===》ulimit -a ===>4k  ==>系统建议值
	===》64k  ===》root用户测试实际值
	 16k,  6k ,


4、如果读端关闭，能不能写？ 为什么 ？===》不能写 ==》SIGPIPE 信号
   如果写端关闭，能不能读？ 为什么 ？===》不能读 ==》read不阻塞
    ===》管道在操作过程中必须保证读写端同步。


作业：
	如何在父子进程中使用无名管道完成父子进程间的双工通信。









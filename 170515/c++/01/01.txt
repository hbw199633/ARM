C++之父  B.S

1、1983 年 C++ 诞生
2、1993 年 引入RTTL  命名空间
3、1997 年 美国国家标准
4、1998 年 国际标准
5、2011 年 最近一次修正 c11

C ===》C++ ===》Java

特点：
1、c++ 完全支持c语言，c语言属于c++的子集；
2、c++ 完全支持面向对象编程， 也支持面向过程编程 也支持泛型编程；
3、c++ 的关键字扩增到63个


5、编程环境：
	1、代码文件： xxx.cpp 后缀结尾
	2、编译器：   g++  xxx.cpp 
	3、头文件：   #include <iostream> ====>以后所有的c++头文件
				  都没有.h;

	4、基本IO：   printf  ===》cout
				  scanf   ===》cin

	5、使用基本io的时候要加入标准命名空间；
			using namespace std;
	   如果没有以上语句则要写成如下形式：
	   	    std::cout<< "asdasfdsafd" << std::endl;

	6、如果要使用c语言的函数和方法必须包含c语言的头文件
	   但是不能有.h 同时头文件必须以 c 开头；
	
练习：
	编写一个c++ 程序可以输出3行hello 语句；

	思考题：输出是否有缓存？ 满缓存是多少字节？是否与c的printf一样？

	编写一个c++程序，可以获取用户输入的两个数字并将
	数字之和打印输出。
	

输出的格式转换：
 dec 输出是十进制
 hex 输出是十六进程
 oct 输出是八进制

 cin输入的时候，会自动过滤空白符；

============================================================
c++ 特有： 命名空间 ===》using namespace xxxx;

目的：将标识符的名字在一定范围内限制，避免多文件过程中的变量名字冲突；


命名空间的名称有两种：
1、系统命名空间：	std;
2、用户自定义空间： myspace;


一般自定义格式如下：

namespace  xxx
{
		//作用域；
}

====》完整格式的自定义命名空间；

注意：命名空间不能单独在函数内部定义
	  命名空间要在调用位置之前声明
	  命名空间可以分段定义，同一命名空间可以合并；


eg： namespace  myspace
	 {
		int		a;
		float	b;
		char	c;

		int  test(int a ,int b)
		{

		}
	 }


使用命名空间：
1、using namespace   xxxx;  ///放在使用内部变量之前；
	之后的代码中默认会自动将变量与xxx命名空间匹配；

2、不用using 使用，直接在代码中加入
	命名空间::内部变量

练习：
	使用命名空间设计两个不同的命名间，并在两个空间中
	各自定义一个相同的函数，并在main中使用不同方式调用
	测试；

=============================================================
c++ 特点2： 引用

一般格式： <存储类型>  类型  &引用名称= 目标变量；
eg：  int a  = 100;
	  int &ra = a;  ///ra就是一个引用，并且与a变量具有相同的地址；

注意区别：
	  引用用于变量的引用不是常量；
	  int a = 100;
	  int *pa = &a;  ///pa是一个指针，指向a变量的地址；

引用与原始变量使用的是同一个内存地址，只是称呼不同；

引用的主要使用方式：

1、函数的参数：
	===>详见  swap.cpp

练习：
	使用引用传参方式，完成两个整形变量的大小比较，并输出
	大的值；

2、函数的返回值：
	===》int ret = test(); ///test()函数执行的结果返回并赋值给
							  ret变量；
	===》test() = 5;
	===》详细见： fun.cpp

练习：
	将刚才比较大小的程序修改为，以引用方式返回其中较小的
	数据值并在main中输出； ===>max.cpp


	如何设计一个引用为返回值的函数可以通过传入不同的参数
	完成指定数组的成员赋值,比如：
	   int a[10]={0};

	   set_array(3) = 100;
思考题：
1、引用能不能引用一个字符串，操作有没有差异？
   1.1 能不能引用字符串常量：
		char * s = "adfsadfafdsfasd";
		char * p = s;
		char * &rs = p;

		char &rs = s;  ///编译不通过，类型不匹配
		char* &rs3= s; ///编译通过有警告，char * ps = "asdfa",有警告；////char &rs = 100;
		char &rs2 = *s; ///编译通过，
		
		cout<< rs<<endl;  ///前面编译不通过
		cout<< rs2 <<endl;  ///输出的是首字符，不能修改
		cout<< &rs2 <<endl; ///输出的是完整字符串
	
		

	
	1.2 能不能引用数组形字符串：
		char s[128] ="asdfasdf";
		char &rs = s;  ///编译不通过，类型不匹配，类似141行
		char &rs2 = s[0]; //可以编译通过

		cout<< rs <<endl;  ///空
		cout<< &rs2 <<endl; ///完整字符串
		cout<< rs2 <<endl; ///首字符，可以修改

	
2、引用能不能引用一个结构体，操作有没有差异？
   没有差异，类似普通变量；

	提醒：
	1、c++的结构体 可以在定义完毕结构体后
	   使用的时候不用再加 struct 关键字；
	
	2、c++的结构体中可以定义函数；

	3、c的for循环前要定义一个循环变量i
	   c++可以在for的(int i= 0;i<xx;i++);


3、引用能不能引用一个指针，操作有没有差异？
   可以做指针的引用，操作过程类似与指针；

===========================================================
c++ 的内存管理：===》堆区内存；

不论是否是c++ or  c编写的程序，运行过程中都具有4G虚拟内存；
1G ==os
8-10M ==》栈
～3G  ==》堆 ====>内存最大，多 需要手工申请和释放
      ==》静态存储区
	  ==》常量区
	  ==》文本区

C： 堆区 ===>申请  malloc()
			 释放  free（）
			 头文件 stdlib.h
			 检测	valgrind


c++ 堆区 ===>申请   new   关键字	
             释放   delete 关键字
			 检测   valgrind  第三方软件；

1、申请堆区内存：new  格式如下：
	目标类型指针 =  new 类型；
	eg： int *pa =  new int;     ///申请单个变量
		 int *pb =  new int[10]; ///申请一个整形数组

	
	第一步： 要判断 new 结果的返回值是否为NULL；
    第二步： 申请的内存是否干净，c++ 不用了；
	第三步： 申请的内存能不能使用，赋值要成功；
	第四步： 读写内存是否越界
	第五步： 内存释放是否完整，不能有内存泄露；


2、释放内存：  delete 格式如下：
	delete  目标指针；
	eg： delete pa;   ///单个变量释放
		 delete [] pb; ///数组的释放

	

练习：
	根据以上知识点，设计一个程序可以申请不同基本数据
	类型的数据并完成赋值测试和释放，最终用内存检测工具
	测试效果。

相同点：
	都可以从堆区获取内存；

不同点：
1、malloc是 库函数 ===》函数调用的损耗；
   new   是 关键字 ===》没有mallc的函数损耗；

2、new   可以自动分配内存大小；
   malloc 需要手工设定内存大小；

3、new   可以在申请类对象的时候调用其构造函数
   delete 在释放对象的时候会调用其析构函数
   
   malloc/free  没有该过程；



练习：
	使用new和delete申请一个10个整形内存空间；
	要求用户任意输入10整数并存储到该内存中；
	将该数组中的数据排序之后打印输出；


作业：
	从堆区使用new/delete申请一个10个整数的数组；
	要求设计一个引用方式的函数，可以将数组中所有
	偶数下标的数组成员全部修改为1，并最终将数组
	遍历输出；



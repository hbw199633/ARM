c++: 字符串类型  string  << STL 类对象

头文件：  #include  <string>

使用格式： string  变量名称；
	eg：   string  s;

注意：
1、string 类型的变量完全可以类似普通变量的操作
	进行变量 = 值的赋值操作；

2、string 类型的变量之间可以互相使用> < == 来判断
    字符串的大小，规则类似与c的strcmp效果

3、多个string类型的字符串可以通过 + 操作符号达到
   c的strcat的效果；

思考题：
1、如何获取当前字符串的长度？
	 string 类型的类有一个成员函数 length可以获取其长度

2、如何将一个已经赋值的字符串变量清空？
	 string 类型的类有一个成员函数 clear 可以清空字符串

3、如何在一个string类型的字符串中找到一个指定的另一个字符串    
	 string 类型的类有一个成员函数 find 可以找到指定字符串


c 数组 ===》c++ 容器 vector

头文件： #include <vector>

一般格式： 
	vector<类型> 变量名称；
	vector<类型> 变量名称(长度)；===>约定容器大小完全参考c的数组操作
	vector<类型> 变量名称(长度，默认值)；

eg：vector<int>  a;
	默认有一个容量，但是在push函数的过程中
	会自动增加容量。


vector 属于STL的一部分，在操作过程中需要使用
迭代器 来依次遍历，而尽量不要使用数组形式遍历；

两个成员函数完成数组的操作：
push_back()
pop_back();
==========>该操作方式会将数据以栈的形式存储到容器vector中

iterator it; 该迭代器可以从容器的开头向末尾依次遍历；

练习：
1、使用vector容器定义一个浮点数数组，可以存储
   10个学生的成绩并使用倒序形式输出。


思考题：
1、vector容器存储的数据在那个区域存储？怎么证明？
	都在堆区，内存释放是在该对象作用域结束时候；

2、vector容器能不能存储string类型的数据？每个string
   大小是否一样？
	可以存储string类型数据，大小不一定一样。
	会自动匹配并适应字符串的大小；

vector容器 与 c数组 关系：
1、相同点
	都可以存储同类型数据的大块内存；
	都可以使用数组下标形式访问；

2、不同点
	vector的容量可以动态自动调整
	数组需要程序员手工设置

	vector的遍历方式丰富
	数组只有一个循环遍历

	vector 默认存储在堆区，不用释放内存；
	数组 指定存储到堆区，需要手工释放；

=======================================================
函数的重载 ======》reload ===>同名函数

在c++中如果一个函数需要同名但是不同参数
则可以考虑用函数重载功能实现；在c语言中不支持；

int  add(int a ,int b);
int  add(int a, float b);  ===>重载函数


目的：为了保证代码的延续性和后期的扩展性；
注意：重载是c++ 的特性，但不是面向对象的特性；
判断是否重载的依据：
1、函数名称相同；
2、函数的参数类型不同，或者参数个数不同；
3、函数的返回值不影响重载的判断；

练习：
	设计一组重载函数可以输出字符串内容
	并根据参数的不同输出不同的形式；比如

	show_string(string s); ///s 为空的判断
	show_string(string s,int count);  //count为负值判断
	 ///根据count决定输出的次数
	show_string(string s,float c);  //c大于s长度的判断
	 //根据c的不同决定输出的s字符个数

=====>如果在参数类型中存在兼容类型

char == short == int == long ===>默认按照int匹配，否则必须严格匹配。
		
float  == double  =====>在程序运行结果会自动类型提升按照大类型匹配


思考题：
	如何使用函数重载功能，完成任意两个数字的大小
	比较操作；
	max_test(long  a, long b);
	max_test(double ,double);
	max_test(long ,double);
	max_test(double ,long);

===>模板编程===》泛型编程
格式： template < 类型 变量>
 eg：  template < class T>
	
	max_test(T a,T b);
	{
		if(a > b)
			cout << "max = " << a <<endl;
		else
			cout << "max =" <<  b << endl;
		return 0;
	}

练习：
	编写一个函数模板，可以完成任意两个相同类型数据的交换动作。
	数据可能是int  short  long  float  sring 。。。。



形参默认值： ===》c++ 特有的特性 ==》在定义函数的时候
				给函数的形式参数赋初始默认值；


int add(int a,int b); // a b 是形参，值是随机值在栈区

在工程中除过重载的扩展函数参数类型和个数以外
还需要参数裁剪，比如原始函数定义在后期需要调整
减少个数，则优先考虑形参默认值；

int add(int a,int b= 0); ///其中b= 0 就是形参默认值


注意事项：
1、形参默认值在使用过程中必须从右向左依次使用默认值
2、所有的参数都可以设置默认值，但是在调用的时候不一定
   赋值；
3、如果函数重载与函数形参默认值有冲突的时候，可能编译不过；
	 int add(int a,int b);
	 int add(int a,int b,int c = 0);
	 add(3,4);///出问题，不能匹配合适的函数

4、形参默认值函数在声明和定义的位置要考虑一致性
	如果声明中有形参默认值，则定义部分必须为空。
	如果声明中没有形参默认值，则定义部分的形参默认值无效；

练习题：
	设计几个不同函数，依次设置其形参默认值，尝试
	输出其不同的默认值并在函数内部修改后在输出；


c++ 特性之：内联函数

C语言的宏函数： 使用宏函数完成两个整数的大小比较
				并返回大的值；

#define  MAX_FUN(a,b) {a>b?a:b}
#define  MAX_FUN(a,b) {(a)>(b)?(a):(b)}

以上宏函数会在编译完毕最终以字符串替换的形式展开
在目标代码中；在宏函数中可能存在字符串替换优先级问题
所以c++ 提倡不再使用宏函数 全部用内敛函数代替；

c++ 的内联函数格式：
inline 函数返回值  函数名称（形参列表）
{
	///函数体实现部分；
}

eg：
inline int max_fun(int a,int b)
{
	if(a > b) return a;
	else	  return b;
}
在c++ 函数中只要以inline开头表示该函数希望是内联函数
但是最终取决与编译器的编译过程；

目的是在代码中将内联函数最终以代码形式展开的目标位置；
注意：如果内敛函数中出现循环等复杂逻辑
      inline无效；


内敛函数与c的宏函数有什么不同：

1、宏函数是在编译阶段处理，是纯字符串替换；
   内联函数是运行阶段处理，是函数逻辑替换；

2、宏函数无法调试；
   内联函数可以调试；

3、宏函数没有返回值;
   内联函数有返回值；

4、宏函数不能访问类成员；
   内联函数可以访问类成员；

练习题：
	使用宏函数和内联函数分别完成一个函数
	可以用于两个整数数字的交换；

	#define swap_int(a,b) {(a)=(a)^(b); \
						   (b)=(a)^(b); \
						   (a)=(a)^(b)}

	#difine swap_int2(a,b){   int c \
							  c = a;\
							  a = b;\
							  b = c;\
						  }

	inline int swap_int3(int &ra, int &rb)
	{
		int c = ra;
		ra = rb;
		rb = c;
		return 0;
	}


练习：
1、使用内联函数完成一个测试string类型字符串长度的函数；
	inline int string_length();

2、使用重载函数完成一个错误处理函数，可以接入多个不同
   类型的传参并组织字符串输出，比如
    myerror("fopen error ");  ===>fopen erorr;
	myerror("fopen error",1); ===>type = 1, msg = fopen error;
	myerror("file","fclose",12456) ===>将12456的秒值转换为时间
									2016/12/27 file mode  flose error

3、使用模板函数完成一个计算器程序的编写测试效果；


作业：
	编程测试并验证inline内联函数是否在代码中
	正常展开；

	一般默认的编译选项没有做优化，所以内联函数以默认的普通文件形式
	加载，如果编译过程中加入 -O3 的最优编译，则inline生效。


	





	




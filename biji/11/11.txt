二维数组：	
	二位数组的初始化：
	默认初始化int a[10][10]={0}；
	不初始化：全局变量和static定义的二维数组
	部分初始化：
		int a[10][10]={{10,9,6,8},{6,5,4,8}};
		int a[10][10]={{10,9,6,8},,{6,5,4,8}};//错误
	全部初始化：
		int a[5][5]={{10,9,6,8,7},
					 {6,5,4,8,6},
					 {5,4,3,2,1},
					 {6,8,7,9,1},
					 {4,5,6,7,8}};
	不定长初始化
		int a[][10]={{10,9,6,8},{6,5,4,8}};
======================================================
指针==>C语言特有的
指针==>C新的构造数据类型
定义格式：
	<存储类型> 数据类型 *变量名称
				 char	  *pa;==》目标内存大小1个字节
				 short	  *pb;==》目标内存大小2个字节
				 int	  *pc;==》目标内存大小4个字节
				 ...
指针的初始化：
	1、使用NULL进行初始化；
		char *pc = NULL;
	2、使用变量初始化：
		char c = 5;
		char *pc = &c;  //变量定义和变量的赋值
		c属于在栈区定于的变量用于存储数据
		pc是c变量的实际地址，*变量的指针符号
		*pc是c地址中存储的实际数据
	3、使用其他指针初始化
		char c = 5;
		char *pc = &c;
		char *pb = pc;
	4、使用绝对地址初始化
		char *pc = 0x999999999;
指针的应用：
	1、赋值：
		指针先定义，后赋值
		int *pa; //野指针，小心定义
		int *pa = NULL;
		int a = 5, b = 10;
		pa = &a; //将普通变量的地址赋值为指针变量
		pa = &b;
		获取指针关联内存中的数据
		"%d",*pa; //打印地址中的数据
		"%p",pa;  //打印地址的值
	注意事项：
	指针变量类型与目标类型不统一：
		1、指针指向类型 < 目标类型
		int a = 500;
		char *p = &a;
		2、指针指向类型 > 目标类型
		char a = 'a';
		int *p = &a;
	2、运算==》算数运算 关系运算 赋值运算
		算数运算： + - ++ --
		char c[32]={'a','b','c','d','e','f'}
		char *p = &c[0];
		pc = pc + 2 ; //*pc=c;
		pc = pc++;	  //*pc=d;
		pc = pc-3;	  //*pc=a;
	定义一个字符数组，可以获取用户输入的字符串，使用指针方式，遍历输出字符串
		注意：
		1、 p +n ==> p 本身不变 ，除非赋值；
			p = p+n;==>p有变化
			p++;p本身在变化
		2、p+n;==>n不是数字，是单位
				  p指向数据单元的单位
		如果p指向char则n每次偏移n*char个字节
		如果p指向int则n每次偏移n*int个字节
		3、p1 = &a[0];
		   p2 = p1+5;
		p2 - p1 ==?不是地址,是两个地址之间间隔的单元数
		不论：p1 p2所指向的a数组是int还是char
			  相减之后都是数据单元个数
练习:定义一个数组，初始化10个整数，用指针指向开始和结
	 尾，测试两个指针相减的结果	
2、关系运算符：== > >= < <= !=
	关系运算符对于指针变量比较的是纯地址大小
	char c[10]={0,1,2,3,4,5,6,7,8,9}
	char *p1=&c[0];
	char *p2=&c[9];
	边界判断(p1 < p2) ==> 0xbf... < 0xbf...
	== 一般与NULL比较 if(p1==NULL)  //p1不可用
	!=			      if(p1!=NULL)  //p1指向有效内存
	char *p3=NULL;
	p3 = p1;
	if(NULL=p3)	 //避免出现if(p3=NULL)
	{
		p3++;
	}	

	if(p==NULL) if(p!=NULL)
	if(p=NULL) //合法赋值，没错
	if(NULL==p) if(NULL!=p)
	if(NULL=p) //编译器报错
3、赋值运算符 = += -=
	=  主要用于给指针赋值或者初始化
	要求：=左边是指针变量，右边是地址或用类型变量
	int *p1=NULL;
	int *p2=p1;
	+= ==> p+=3; p=p+3;
	-= ==> p-=2; p=p-2;
strcmp(),用指针方式实现
===================================================
数组指针==》字符数组和字符指针
	数组指针  ==》本质是指针，只不过是数组的
	指针数组  ==》本质是数组，只不过是指针的
数组指针：
	数组定义：char c[128] = {0};
    指针定义：char *p = NULL;
	数组指针关联：p = &c[0];
	p 就是数组指针，可以表示数组元素
	==》等价关系
		c[i]==p[i]==*(p+i)==*(c+i)
	==》不等价关系
		p是变量可以改变
		c是数组名是常量不能改变
定义一个字符数组，用数组指针验证等价关系，和赋值运算符
指针数组：==>数组
	int a = 100;
	int b = 200;
	int c = 300;
	int *p[3] ={&a,&b,&c};
	printf("a=%d p=%d",a,*(p[0]));
void指针：==》控指针 ==》纯粹的地址
	变量的定义不允许使用void类型；void a; ?多大空间
	指针的定于可以使用void类型void *p;//默认的地址空间
所有的指针都是4字节大小(原因：地址范围)
	bzero(void *s,size_t n);
	s任意字符串，n是字符串长度
	给一个字符串的收地址和字符串的大小，该函数会清空这
	个字符串
	char c[128]={"fsadklfhsdgdsjklghsdjfhgjshdfghsl"};
	bzero(c,szieof(c));
	c[128]={0};
void *类型的指针一般用于两个地方
	1、函数传参数：void bzero(void* s,szie_t n);
	2、函数返回值：void *memcpy(void *dest, const void *src, size_t n)
	作业：strcat,strcpy用指针方式完成


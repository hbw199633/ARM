.\" ** You probably do not want to edit this file directly **
.\" It was generated using the DocBook XSL Stylesheets (version 1.69.1).
.\" Instead of manually editing it, you probably should edit the DocBook XML
.\" source for it and then use the DocBook XSL Stylesheets to regenerate it.
.TH "VALGRIND" "1" "01/29/2007" "Release 3.2.3" "Release 3.2.3"
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.SH "NAME"
valgrind \- a suite of tools for debugging and profiling programs
.SH "SYNOPSIS"
.HP 9
\fBvalgrind\fR [[\fIvalgrind\fR]\ [\fIoptions\fR]] [\fIyour\-program\fR] [[\fIyour\-program\-options\fR]]
.SH "DESCRIPTION"
.PP
\fBValgrind\fR
is a flexible program for debugging and profiling Linux executables. It consists of a core, which provides a synthetic CPU in software, and a series of "tools", each of which is a debugging or profiling tool. The architecture is modular, so that new tools can be created easily and without disturbing the existing structure.
.PP
This manual page covers only basic usage and options. For more comprehensive information, please see the HTML documentation on your system:
\fI/usr/share/doc/valgrind/html/index.html\fR, or online:
\fIhttp://www.valgrind.org/docs/manual/index.html\fR.
.SH "INVOCATION"
.PP
\fBValgrind\fR
is typically invoked as follows:
.sp
.nf
    valgrind program args
.fi
.sp
This runs
\fBprogram\fR
(with arguments
\fBargs\fR) under Valgrind using the Memcheck tool. Memcheck performs a range of memory\-checking functions, including detecting accesses to uninitialised memory, misuse of allocated memory (double frees, access after free, etc.) and detecting memory leaks.
.PP
To use a different tool, use the
\fB\-\-tool\fR
option:
.sp
.nf
    valgrind \-\-tool=toolname program args
.fi
.PP
The following tools are available:
.TP 3
\(bu
\fBcachegrind\fR
is a cache simulator. It can be used to annotate every line of your program with the number of instructions executed and cache misses incurred.
.TP
\(bu
\fBcallgrind\fR
adds call graph tracing to cachegrind. It can be used to get call counts and inclusive cost for each call happening in your program. In addition to cachegrind, callgrind can annotate threads separatly, and every instruction of disassembler output of your program with the number of instructions executed and cache misses incurred.
.TP
\(bu
\fBhelgrind\fR
spots potential race conditions in your program.
.TP
\(bu
\fBlackey\fR
is a sample tool that can be used as a template for generating your own tools. After the program terminates, it prints out some basic statistics about the program execution.
.TP
\(bu
\fBmassif\fR
is a heap profiler. It measures how much heap memory your program uses.
.TP
\(bu
\fBmemcheck\fR
is a fine\-grained memory checker.
.TP
\(bu
\fBnone\fR
performs no function \- it simply runs the program under Valgrind. This is typically used for debugging and benchmarking Valgrind.
.SH "BASIC OPTIONS"
.PP
These options work with all tools.
.TP
\fB\-h \-\-help\fR
Show help for all options, both for the core and for the selected tool.
.TP
\fB\-\-help\-debug\fR
Same as
\fB\-\-help\fR, but also lists debugging options which usually are only of use to Valgrind's developers.
.TP
\fB\-\-version\fR
Show the version number of the Valgrind core. Tools can have their own version numbers. There is a scheme in place to ensure that tools only execute when the core version is one they are known to work with. This was done to minimise the chances of strange problems arising from tool\-vs\-core version incompatibilities.
.TP
\fB\-q \-\-quiet\fR
Run silently, and only print error messages. Useful if you are running regression tests or have some other automated test machinery.
.TP
\fB\-v \-\-verbose\fR
Be more verbose. Gives extra information on various aspects of your program, such as: the shared objects loaded, the suppressions used, the progress of the instrumentation and execution engines, and warnings about unusual behaviour. Repeating the flag increases the verbosity level.
.TP
\fB\-d\fR
Emit information for debugging Valgrind itself. This is usually only of interest to the Valgrind developers. Repeating the flag produces more detailed output. If you want to send us a bug report, a log of the output generated by
\fB\-v \-v \-d \-d\fR
will make your report more useful.
.TP
\fB\-\-tool=<toolname> [default: memcheck] \fR
Run the Valgrind tool called
\fItoolname\fR, e.g. Memcheck, Addrcheck, Cachegrind, etc.
.TP
\fB\-\-trace\-children=<yes|no> [default: no] \fR
When enabled, Valgrind will trace into child processes. This can be confusing and isn't usually what you want, so it is disabled by default.
.TP
\fB\-\-track\-fds=<yes|no> [default: no] \fR
When enabled, Valgrind will print out a list of open file descriptors on exit. Along with each file descriptor is printed a stack backtrace of where the file was opened and any details relating to the file descriptor such as the file name or socket details.
.TP
\fB\-\-time\-stamp=<yes|no> [default: no] \fR
When enabled, each message is preceded with an indication of the elapsed wallclock time since startup, expressed as days, hours, minutes, seconds and milliseconds.
.TP
\fB\-\-log\-fd=<number> [default: 2, stderr] \fR
Specifies that Valgrind should send all of its messages to the specified file descriptor. The default, 2, is the standard error channel (stderr). Note that this may interfere with the client's own use of stderr, as Valgrind's output will be interleaved with any output that the client sends to stderr.
.TP
\fB\-\-log\-file=<filename> \fR
Specifies that Valgrind should send all of its messages to the specified file. In fact, the file name used is created by concatenating the text
\fIfilename\fR, "." and the process ID, (ie. <filename>.<pid>), so as to create a file per process. The specified file name may not be the empty string.
.TP
\fB\-\-log\-file\-exactly=<filename> \fR
Just like
\fB\-\-log\-file\fR, but the suffix
".pid"
is not added. If you trace multiple processes with Valgrind when using this option the log file may get all messed up.
.TP
\fB\-\-log\-file\-qualifier=<VAR> \fR
When used in conjunction with
\fB\-\-log\-file\fR, causes the log file name to be qualified using the contents of the environment variable
$VAR. This is useful when running MPI programs. For further details, see
Section 2.3 "The Commentary"
in the manual.
.TP
\fB\-\-log\-socket=<ip\-address:port\-number> \fR
Specifies that Valgrind should send all of its messages to the specified port at the specified IP address. The port may be omitted, in which case port 1500 is used. If a connection cannot be made to the specified socket, Valgrind falls back to writing output to the standard error (stderr). This option is intended to be used in conjunction with the
valgrind\-listener
program. For further details, see
Section 2.3 "The Commentary"
in the manual.
.SH "ERROR\-RELATED OPTIONS"
.PP
These options are used by all tools that can report errors, e.g. Memcheck, but not Cachegrind.
.TP
\fB\-\-xml=<yes|no> [default: no] \fR
When enabled, output will be in XML format. This is aimed at making life easier for tools that consume Valgrind's output as input, such as GUI front ends. Currently this option only works with Memcheck.
.TP
\fB\-\-xml\-user\-comment=<string> \fR
Embeds an extra user comment string at the start of the XML output. Only works when
\fB\-\-xml=yes\fR
is specified; ignored otherwise.
.TP
\fB\-\-demangle=<yes|no> [default: yes] \fR
Enable/disable automatic demangling (decoding) of C++ names. Enabled by default. When enabled, Valgrind will attempt to translate encoded C++ names back to something approaching the original. The demangler handles symbols mangled by g++ versions 2.X, 3.X and 4.X.
.sp
An important fact about demangling is that function names mentioned in suppressions files should be in their mangled form. Valgrind does not demangle function names when searching for applicable suppressions, because to do otherwise would make suppressions file contents dependent on the state of Valgrind's demangling machinery, and would also be slow and pointless.
.TP
\fB\-\-num\-callers=<number> [default: 12] \fR
By default, Valgrind shows twelve levels of function call names to help you identify program locations. You can change that number with this option. This can help in determining the program's location in deeply\-nested call chains. Note that errors are commoned up using only the top four function locations (the place in the current function, and that of its three immediate callers). So this doesn't affect the total number of errors reported.
.sp
The maximum value for this is 50. Note that higher settings will make Valgrind run a bit more slowly and take a bit more memory, but can be useful when working with programs with deeply\-nested call chains.
.TP
\fB\-\-error\-limit=<yes|no> [default: yes] \fR
When enabled, Valgrind stops reporting errors after 10,000,000 in total, or 1,000 different ones, have been seen. This is to stop the error tracking machinery from becoming a huge performance overhead in programs with many errors.
.TP
\fB\-\-error\-exitcode=<number> [default: 0] \fR
Specifies an alternative exit code to return if Valgrind reported any errors in the run. When set to the default value (zero), the return value from Valgrind will always be the return value of the process being simulated. When set to a nonzero value, that value is returned instead, if Valgrind detects any errors. This is useful for using Valgrind as part of an automated test suite, since it makes it easy to detect test cases for which Valgrind has reported errors, just by inspecting return codes.
.TP
\fB\-\-show\-below\-main=<yes|no> [default: no] \fR
By default, stack traces for errors do not show any functions that appear beneath
\fBmain()\fR
(or similar functions such as glibc's
\fB__libc_start_main()\fR, if
\fBmain()\fR
is not present in the stack trace); most of the time it's uninteresting C library stuff. If this option is enabled, those entries below
\fBmain()\fR
will be shown.
.TP
\fB\-\-suppressions=<filename> [default: $PREFIX/lib/valgrind/default.supp] \fR
Specifies an extra file from which to read descriptions of errors to suppress. You may use as many extra suppressions files as you like.
.TP
\fB\-\-gen\-suppressions=<yes|no|all> [default: no] \fR
When set to
\fIyes\fR, Valgrind will pause after every error shown and print the line:
.sp
.nf
    \-\-\-\- Print suppression ? \-\-\- [Return/N/n/Y/y/C/c] \-\-\-\-
.fi
.sp
The prompt's behaviour is the same as for the
\fB\-\-db\-attach\fR
option (see below).
.sp
If you choose to, Valgrind will print out a suppression for this error. You can then cut and paste it into a suppression file if you don't want to hear about the error in the future.
.sp
When set to
\fIall\fR, Valgrind will print a suppression for every reported error, without querying the user.
.sp
This option is particularly useful with C++ programs, as it prints out the suppressions with mangled names, as required.
.sp
Note that the suppressions printed are as specific as possible. You may want to common up similar ones, eg. by adding wildcards to function names. Also, sometimes two different errors are suppressed by the same suppression, in which case Valgrind will output the suppression more than once, but you only need to have one copy in your suppression file (but having more than one won't cause problems). Also, the suppression name is given as
<insert a suppression name here>; the name doesn't really matter, it's only used with the
\fB\-v\fR
option which prints out all used suppression records.
.TP
\fB\-\-db\-attach=<yes|no> [default: no] \fR
When enabled, Valgrind will pause after every error shown and print the line:
.sp
.nf
    \-\-\-\- Attach to debugger ? \-\-\- [Return/N/n/Y/y/C/c] \-\-\-\-
.fi
.sp
Pressing
\fIRet\fR, or
\fIN Ret\fR
or
\fIn Ret\fR, causes Valgrind not to start a debugger for this error.
.sp
Pressing
\fIY Ret\fR
or
\fIy Ret\fR
causes Valgrind to start a debugger for the program at this point. When you have finished with the debugger, quit from it, and the program will continue. Trying to continue from inside the debugger doesn't work.
.sp
\fIC Ret\fR
or
\fIc Ret\fR
causes Valgrind not to start a debugger, and not to ask again.
.sp
\fBNote:\fR\fB\-\-db\-attach=yes\fR
conflicts with
\fB\-\-trace\-children=yes\fR. You can't use them together. Valgrind refuses to start up in this situation.
.sp
May 2002: this is a historical relic which could be easily fixed if it gets in your way. Mail us and complain if this is a problem for you.
.sp
Nov 2002: if you're sending output to a logfile or to a network socket, I guess this option doesn't make any sense. Caveat emptor.
.TP
\fB\-\-db\-command=<command> [default: gdb \-nw %f %p] \fR
Specify the debugger to use with the
\fB\-\-db\-attach\fR
command. The default debugger is gdb. This option is a template that is expanded by Valgrind at runtime.
%f
is replaced with the executable's file name and
%p
is replaced by the process ID of the executable.
.sp
This specifies how Valgrind will invoke the debugger. By default it will use whatever GDB is detected at build time, which is usually
/usr/bin/gdb. Using this command, you can specify some alternative command to invoke the debugger you want to use.
.sp
The command string given can include one or instances of the
%p
and
%f
expansions. Each instance of
%p
expands to the PID of the process to be debugged and each instance of
%f
expands to the path to the executable for the process to be debugged.
.TP
\fB\-\-input\-fd=<number> [default: 0, stdin] \fR
When using
\fB\-\-db\-attach=yes\fR
and
\fB\-\-gen\-suppressions=yes\fR, Valgrind will stop so as to read keyboard input from you, when each error occurs. By default it reads from the standard input (stdin), which is problematic for programs which close stdin. This option allows you to specify an alternative file descriptor from which to read input.
.TP
\fB\-\-max\-stackframe=<number> [default: 2000000] \fR
The maximum size of a stack frame \- if the stack pointer moves by more than this amount then Valgrind will assume that the program is switching to a different stack.
.sp
You may need to use this option if your program has large stack\-allocated arrays. Valgrind keeps track of your program's stack pointer. If it changes by more than the threshold amount, Valgrind assumes your program is switching to a different stack, and Memcheck behaves differently than it would for a stack pointer change smaller than the threshold. Usually this heuristic works well. However, if your program allocates large structures on the stack, this heuristic will be fooled, and Memcheck will subsequently report large numbers of invalid stack accesses. This option allows you to change the threshold to a different value.
.sp
You should only consider use of this flag if Valgrind's debug output directs you to do so. In that case it will tell you the new threshold you should specify.
.sp
In general, allocating large structures on the stack is a bad idea, because (1) you can easily run out of stack space, especially on systems with limited memory or which expect to support large numbers of threads each with a small stack, and (2) because the error checking performed by Memcheck is more effective for heap\-allocated data than for stack\-allocated data. If you have to use this flag, you may wish to consider rewriting your code to allocate on the heap rather than on the stack.
.SH "MALLOC()\-RELATED OPTIONS"
.PP
For tools that use their own version of
malloc()
(e.g. Memcheck and Massif), the following options apply.
.TP
\fB\-\-alignment=<number> [default: 8] \fR
By default Valgrind's
\fBmalloc()\fR,
\fBrealloc()\fR, etc, return 8\-byte aligned addresses. This is standard for most processors. However, some programs might assume that
\fBmalloc()\fR
et al return 16\-byte or more aligned memory. The supplied value must be between 8 and 4096 inclusive, and must be a power of two.
.SH "UNCOMMON OPTIONS"
.PP
These options apply to all tools, as they affect certain obscure workings of the Valgrind core. Most people won't need to use these.
.TP
\fB\-\-run\-libc\-freeres=<yes|no> [default: yes] \fR
The GNU C library (\fBlibc.so\fR), which is used by all programs, may allocate memory for its own uses. Usually it doesn't bother to free that memory when the program ends \- there would be no point, since the Linux kernel reclaims all process resources when a process exits anyway, so it would just slow things down.
.sp
The glibc authors realised that this behaviour causes leak checkers, such as Valgrind, to falsely report leaks in glibc, when a leak check is done at exit. In order to avoid this, they provided a routine called
\fB__libc_freeres\fR
specifically to make glibc release all memory it has allocated. Memcheck therefore tries to run
\fB__libc_freeres\fR
at exit.
.sp
Unfortunately, in some versions of glibc,
\fB__libc_freeres\fR
is sufficiently buggy to cause segmentation faults. This is particularly noticeable on Red Hat 7.1. So this flag is provided in order to inhibit the run of
\fB__libc_freeres\fR. If your program seems to run fine on Valgrind, but segfaults at exit, you may find that
\fB\-\-run\-libc\-freeres=no\fR
fixes that, although at the cost of possibly falsely reporting space leaks in
\fIlibc.so\fR.
.TP
\fB\-\-sim\-hints=hint1,hint2,... \fR
Pass miscellaneous hints to Valgrind which slightly modify the simulated behaviour in nonstandard or dangerous ways, possibly to help the simulation of strange features. By default no hints are enabled. Use with caution! Currently known hints are:
.RS
.TP 3
\(bu
\fBlax\-ioctls: \fR
Be very lax about ioctl handling; the only assumption is that the size is correct. Doesn't require the full buffer to be initialized when writing. Without this, using some device drivers with a large number of strange ioctl commands becomes very tiresome.
.TP
\(bu
\fBenable\-inner: \fR
Enable some special magic needed when the program being run is itself Valgrind.
.RE
.TP
\fB\-\-kernel\-variant=variant1,variant2,...\fR
Handle system calls and ioctls arising from minor variants of the default kernel for this platform. This is useful for running on hacked kernels or with kernel modules which support nonstandard ioctls, for example. Use with caution. If you don't understand what this option does then you almost certainly don't need it. Currently known variants are:
.RS
.TP 3
\(bu
\fBbproc: \fR
Support the sys_broc system call on x86. This is for running on BProc, which is a minor variant of standard Linux which is sometimes used for building clusters.
.RE
.TP
\fB\-\-show\-emwarns=<yes|no> [default: no] \fR
When enabled, Valgrind will emit warnings about its CPU emulation in certain cases. These are usually not interesting.
.TP
\fB\-\-smc\-check=<none|stack|all> [default: stack] \fR
This option controls Valgrind's detection of self\-modifying code. Valgrind can do no detection, detect self\-modifying code on the stack, or detect self\-modifying code anywhere. Note that the default option will catch the vast majority of cases, as far as we know. Running with
\fIall\fR
will slow Valgrind down greatly (but running with
\fInone\fR
will rarely speed things up, since very little code gets put on the stack for most programs).
.SH "DEBUGGING VALGRIND OPTIONS"
.PP
There are also some options for debugging Valgrind itself. You shouldn't need to use them in the normal run of things. If you wish to see the list, use the
\fB\-\-help\-debug\fR
option.
.SH "MEMCHECK OPTIONS"
.TP
\fB\-\-leak\-check=<no|summary|yes|full> [default: summary] \fR
When enabled, search for memory leaks when the client program finishes. A memory leak means a malloc'd block, which has not yet been free'd, but to which no pointer can be found. Such a block can never be free'd by the program, since no pointer to it exists. If set to
\fIsummary\fR, it says how many leaks occurred. If set to
\fIfull\fR
or
\fIyes\fR, it gives details of each individual leak.
.TP
\fB\-\-show\-reachable=<yes|no> [default: no] \fR
When disabled, the memory leak detector only shows blocks for which it cannot find a pointer to at all, or it can only find a pointer to the middle of. These blocks are prime candidates for memory leaks. When enabled, the leak detector also reports on blocks which it could find a pointer to. Your program could, at least in principle, have freed such blocks before exit. Contrast this to blocks for which no pointer, or only an interior pointer could be found: they are more likely to indicate memory leaks, because you do not actually have a pointer to the start of the block which you can hand to
\fBfree\fR, even if you wanted to.
.TP
\fB\-\-leak\-resolution=<low|med|high> [default: low] \fR
When doing leak checking, determines how willing
\fBmemcheck\fR
is to consider different backtraces to be the same. When set to
\fIlow\fR, only the first two entries need match. When
\fImed\fR, four entries have to match. When
\fIhigh\fR, all entries need to match.
.sp
For hardcore leak debugging, you probably want to use
\fB\-\-leak\-resolution=high\fR
together with
\fB\-\-num\-callers=40\fR
or some such large number. Note however that this can give an overwhelming amount of information, which is why the defaults are 4 callers and low\-resolution matching.
.sp
Note that the
\fB\-\-leak\-resolution=\fR
setting does not affect
\fBmemcheck's\fR
ability to find leaks. It only changes how the results are presented.
.TP
\fB\-\-freelist\-vol=<number> [default: 5000000] \fR
When the client program releases memory using
\fBfree\fR
(in
C) or delete (C++), that memory is not immediately made available for re\-allocation. Instead, it is marked inaccessible and placed in a queue of freed blocks. The purpose is to defer as long as possible the point at which freed\-up memory comes back into circulation. This increases the chance that
\fBmemcheck\fR
will be able to detect invalid accesses to blocks for some significant period of time after they have been freed.
.sp
This flag specifies the maximum total size, in bytes, of the blocks in the queue. The default value is five million bytes. Increasing this increases the total amount of memory used by
\fBmemcheck\fR
but may detect invalid uses of freed blocks which would otherwise go undetected.
.TP
\fB\-\-workaround\-gcc296\-bugs=<yes|no> [default: no] \fR
When enabled, assume that reads and writes some small distance below the stack pointer are due to bugs in gcc 2.96, and does not report them. The "small distance" is 256 bytes by default. Note that gcc 2.96 is the default compiler on some older Linux distributions (RedHat 7.X) and so you may need to use this flag. Do not use it if you do not have to, as it can cause real errors to be overlooked. A better alternative is to use a more recent gcc/g++ in which this bug is fixed.
.TP
\fB\-\-partial\-loads\-ok=<yes|no> [default: no] \fR
Controls how
\fBmemcheck\fR
handles word\-sized, word\-aligned loads from addresses for which some bytes are addressible and others are not. When
\fIyes\fR, such loads do not elicit an address error. Instead, the loaded V bytes corresponding to the illegal addresses indicate Undefined, and those corresponding to legal addresses are loaded from shadow memory, as usual.
.sp
When
\fIno\fR, loads from partially invalid addresses are treated the same as loads from completely invalid addresses: an illegal\-address error is issued, and the resulting V bytes indicate valid data.
.sp
Note that code that behaves in this way is in violation of the the ISO C/C++ standards, and should be considered broken. If at all possible, such code should be fixed. This flag should be used only as a last resort.
.TP
\fB\-\-undef\-value\-errors=<yes|no> [default: yes] \fR
Controls whether
\fBmemcheck\fR
detects dangerous uses of undefined value errors. When
\fIyes\fR, Memcheck behaves like Addrcheck, a lightweight memory\-checking tool that used to be part of Valgrind, which didn't detect undefined value errors. Use this option if you don't like seeing undefined value errors.
.SH "CACHEGRIND OPTIONS"
.PP
Manually specifies the I1/D1/L2 cache configuration, where
\fIsize\fR
and
\fIline_size\fR
are measured in bytes. The three items must be comma\-separated, but with no spaces, eg:
.sp
.nf
    valgrind \-\-tool=cachegrind \-\-I1=65535,2,64
.fi
.sp
You can specify one, two or three of the I1/D1/L2 caches. Any level not manually specified will be simulated using the configuration found in the normal way (via the CPUID instruction for automagic cache configuration, or failing that, via defaults).
.TP
\fB\-\-I1=<size>,<associativity>,<line size> \fR
Specify the size, associativity and line size of the level 1 instruction cache.
.TP
\fB\-\-D1=<size>,<associativity>,<line size> \fR
Specify the size, associativity and line size of the level 1 data cache.
.TP
\fB\-\-L2=<size>,<associativity>,<line size> \fR
Specify the size, associativity and line size of the level 2 cache.
.SH "CALLGRIND OPTIONS"
<xi:include></xi:include>.SH "MASSIF OPTIONS"
.TP
\fB\-\-heap=<yes|no> [default: yes] \fR
When enabled, profile heap usage in detail. Without it, the
\fImassif.pid.txt\fR
or
\fImassif.pid.html\fR
will be very short.
.TP
\fB\-\-heap\-admin=<number> [default: 8] \fR
The number of admin bytes per block to use. This can only be an estimate of the average, since it may vary. The allocator used by
glibc
requires somewhere between 4 to 15 bytes per block, depending on various factors. It also requires admin space for freed blocks, although
\fBmassif\fR
does not count this.
.TP
\fB\-\-stacks=<yes|no> [default: yes] \fR
When enabled, include stack(s) in the profile. Threaded programs can have multiple stacks.
.TP
\fB\-\-depth=<number> [default: 3] \fR
Depth of call chains to present in the detailed heap information. Increasing it will give more information, but
\fBmassif\fR
will run the program more slowly, using more memory, and produce a bigger
\fImassif.pid.txt\fR
or
\fImassif.pid.hp\fR
file.
.TP
\fB\-\-alloc\-fn=<name> \fR
Specify a function that allocates memory. This is useful for functions that are wrappers to
\fBmalloc()\fR, which can fill up the context information uselessly (and give very uninformative bands on the graph). Functions specified will be ignored in contexts, i.e. treated as though they were
\fBmalloc()\fR. This option can be specified multiple times on the command line, to name multiple functions.
.TP
\fB\-\-format=<text|html> [default: text] \fR
Produce the detailed heap information in text or HTML format. The file suffix used will be either
\fI.txt\fR
or
\fI.html\fR.
.SH "HELGRIND OPTIONS"
.TP
\fB\-\-private\-stacks=<yes|no> [default: no] \fR
Assume thread stacks are used privately.
.TP
\fB\-\-show\-last\-access=<yes|some|no> [default: no] \fR
Show location of last word access on error.
.SH "LACKEY OPTIONS"
.TP
\fB\-\-fnname=<name> [default: _dl_runtime_resolve()] \fR
Count calls to <name>.
.TP
\fB\-\-detailed\-counts=<no|yes> [default: no] \fR
Count loads, stores and alu ops.
.SH "SEE ALSO"
.PP
\fI/usr/share/doc/valgrind/html/index.html\fR, and/or
\fIhttp://www.valgrind.org/docs/manual/index.html\fR.
.SH "AUTHOR"
.PP
This manpage has been written by Andres Roldan <aroldan@debian.org> for the Debian Project, but can be used for any other distribution.
.PP
Updated, rearranged and expanded by Robert Walsh <rjwalsh@durables.org> for the 2.4.0 release, and by other Valgrind developers subsequently.

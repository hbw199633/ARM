守护进程：

	制作孤儿进程 ===》设置会话组长 ==》修改工作目录 ==》提文件权限 ==》关闭文件


1、制作孤儿进程：
    创建父子进程 ===》fork()
	父进程退出，子进程保留，===》exit()
	孤儿进程


2、设置会话组长： setsid
    pid_t setsid(void);
	功能：修改当前进程为会话组长。
	参数： 无
	返回值：新的组长pid

3、修改工作目录： chdir

    chdir("/");   ===> chdir("/daemon");

4、修改工作目录的权限掩码： umask
   mode_t umask(mode_t mask);
   功能：修改当前工作目录中文件的默认权限掩码
   参数：mask 目标权限掩码
   返回值： 成功  新的权限掩码
			失败  -1;

5、关闭已经打开的文件描述符： close  getdtablesize
   int getdtablesize(void);
   功能：该函数用于获取当前进程能打开的最大文件描述符
   参数： 无
   返回值：成功  最大描述符
		   失败  -1；


验证是否具备守护进程的特征：
1、ps aux ===>STAT 列 必须有 s  的会话组长
2、ps -ef ===>PPID 列 必须是 1  的孤儿进程
3、ps aux ===>TTY  列 必须是 ？ 的非终端进程



练习题：
1、自己编写一个守护进程，并在该守护进程中加入每隔
   3秒向工作目录下创建一个新的普通文件。




2、设计一个守护进程，完成如下功能要求：
	1、守护进程启动时候，主函数传参带入一个目录路径
	2、要实时检测该目录中现有的文件是否有变化
	3、将有变化的文件名称和时间记录日志
	4、要可以开机启动


===============================================================
多进程存在的问题：

1、多进程时候资源消耗过大； ===》4G
2、直接进程间通信有障碍；   ===》共享内存
3、多进程之间的速度差异；   ===》父快于子
4、多进程的创建个数限制；   ===》ulimit -a 


基于以上问题，提出多线程解决方案：

1、线程是一个轻量级进程；
2、线程是进程中的多个任务；
3、线程是CPU调度的最小单位； << ===== 进程是操作系统调度的最小单位

线程与进程的区别：
资源：
	多线程比多进程多了共享内存；
	多线程和多进程都有私有资源；

空间：
	多线程中所有线程共享进程4g内存；
	多进程中所有进程独享进程4g内存；


多线程的使用框架：
  创建多线程 ====》读写多线程空间 ===》关闭回收多线程；
  pthread_create     回调函数          pthread_cancel/pthread_exit
									   pthread_join

linux的线程模型使用的是POSIX 线程模型 ： pthread;

1、编写代码的时候需要加入三方库头文件： #include <pthread.h>
2、编译代码的时候需要加入库编译选项： gcc xxxx.c  -l pthread


1、创建多线程：pthread_create
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                  void *(*start_routine) (void *), void *arg);
功能：该函数可以用于动态创建一个执行线程；
参数：thread  线程id，一般在创建完毕会自动赋值；
      attr    线程属性，一般不用调整，用NULL 表示默认的优化属性；
	  start_routine 指向指针函数的函数指针；
	               指针函数为： void * fun(void * arg);
				   函数指针为：  xxx (*pfun)(void * arg);
				   ===>pfun == fun ===>函数名字 ===》回调函数
				   ===》线程的执行空间；

	  arg   线程回调函数的参数，即参数4的函数参数；
	        如果没有参数传递用NULL表示；

返回值：成功 0 
		失败 -1

判断一个进程是否是多进程的依据：
1、ps aux ===>STAT 列有 l 符号
2、pstree  |grep a.out  ===>多个线程个数


练习：
	使用以上函数创建一个多线程程序，分别在主线程和子线程中输出不同语句。

思考题：
1、能不能在一个进程中创建多个（3个）以上的多线程？   381 ~ 400 个 == 4G 内存
2、如何验证这些线程是在并发执行？
3、这些线程之间是否可以共享数据，如何共享？


==========================================================
作业：
   设计一个守护进程，默认读取同名配置文件，并根据
   配置文件内容启动相关程序，将启动程序的信息(成功，失败)
   写入日志文件。比如：

	守护进程： abc
	默认配置： /etc/abc.conf ===>  /mnt/xxx
								   /xxx/yyy/b.out
	日志文件： /var/log/abc.log









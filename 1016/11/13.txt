进程间通信：

1、古老的进程间通信：
	无名管道   有名管道    信号

2、IPC通信方式：
	消息队列对象  共享内存对象  信号量集对象

3、SOCKET通信方式：
    TCP   UDP


古老的通信方式：
1、管道 ===》无名管道/有名管道
        
   公共特性：
   1、管道的操作框架；
   创建管道 ===》打开管道 ==》读写管道 ==》关闭管道 ==》销毁管道

   2、所有管道都是 半双工 工作模式

   3、管道是一类特殊文件，操作方式为文件IO，且不支持定位操作；

   4、管道的通信过程必须保证同步；


1.1 无名管道的使用：===》PIPE ===pipe
	私有特性： 没有名称，基于内存；
			   只能用于亲缘关系进程间通信；
			   必须在fork调用之前创建；


	创建无名管道/打开管道；
	#include <unistd.h>

	int pipe(int pipefd[2]);
	功能：该函数可以创建并打开一个无名管道。
	参数：整形数组，有两个元素；
			pipefd[0]  管道的固定读端
			pipefd[1]  管道的固定写端
	返回值：成功 0
			失败 -1；

	读写无名管道：用文件io操作

	读： ssize_t read(int fd, void *buf, size_t count);
	写： ssize_t write(int fd, const void *buf, size_t count);


练习：
	使用无名管道从父进程向子进程传递一个整形数字；
	
思考题：
	无名管道传递数据的原理是什么？ ===>FIFO

	父子进程中都有读写端？ 能不能在一个进程中即读又写？
	如果有多个读端在不同进程中，谁能读到数据？以及数据
	读操作之后还有没有数据？

	根据以上代码编写测试用例验证一个普通无名管道的容量？
	证明管道中的数据是 FIFO形式被取走了，而不是指针移动。

关闭管道： close();
         建议在不进行读写操作的进程中将相关管道端关闭；
销毁管道： 无


管道的同步； 如果一个有效管道通信过程，必须保证读写端同步；
             =====》如果读端存在则必须写端存在
			 -====》如果写端存在则必须读端存在


	验证：如果只有读端，没有写端会有什么异常？===》read不阻塞；
		  如果只有写端，没有读端会有什么异常？===》SIGPIPE异常终止

	===》必须保证读写端同步；


  读写端是一定固定的吗？能不能互换？
  不能互换，都是固定的读写端；

================================================================
有名管道 ====》有名称的管道 ===》FIFO ====》在文件系统中可见文件

具备基本的管道所有特性：
具有有名管道自有的特性：
	1、文件系统可见
	2、文件读写方式调整；
	3、有名管道文件可以单独创建；


使用框架：
	创建有名管道 ===》打开有名管道==》读写有名管道 ==》关闭有名管道 ==》卸载有名管道


1、创建有名管道：
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);
功能：该函数可以在指定路径下创建指定权限的有名管道文件。
参数：pathname 要创建的有名管道路径+名称；
	  mode     要创建的管道文件的权限；
返回值：成功  0
		失败  -1；


2、打开有名管道：open
int open(const char *pathname, int flags);
功能：使用该函数打开一个已经创建好的有名管道；
参数： pathname  管道名称+路径
	   flags  O_RDONLY  只读方式打开管道
			  O_WRONLY  只写方式打开管道
返回值：成功  如果以只读方式打开，则返回值为管道读端
			  如果以只写方式打开，则返回值为管道写端

		失败  -1；

注意：由于管道必须保证读写端同步，如果一端不存在，
      则另一端在该函数位置会阻塞等待。


3、管道的读写： 文件io的read 和  write

	读： ssize_t read(int fd, void *buf, size_t count);
	写： ssize_t write(int fd, const void *buf, size_t count);

练习：
	使用有名管道在两个没有亲缘关系的进程间传送数字，结构体数据；
	并验证是否正确；



4、有名管道的关闭： close() ;

5、卸载有名管道： unlink();
int unlink(const char *pathname);
功能：卸载执行路径下的有名管道文件，即删除管道文件；
参数： pathname 要卸载的目标管道文件
返回值：成功  0
		失败 -1；



思考题：
1、有名管道和无名管道有那些不同？
     有名管道在文件系统中可见，无名管道不可见；
	 管道的生成方式不同，打开方式不同；
	 无名管道只能用于亲缘关系进程，有名管都可以使用；
	
	有名管道文件只是文件符号，不同于普通文件；
	vim 不能编辑有名管道；要读管道用cat等查看工具
						  要写管道用echo等工具写管道
	eg: cat xxx
	    echo "asf" > xxx


2、有名管道的容量是否和无名管道一样 ？
    一样；

3、有名管道能否用于亲缘关系进程使用，必须在fork之前吗 ？
	可以使用，但是必须确保打开的时候在各自进程空间。

注意：有名管道的创建和卸载一般要独立执行，不能和逻辑代码混用
	  除非必要；
只是文件符号，不同于普通文件；

===============================================================

作业：
1、使用无名管道完成父子进程间的双工通信，要证明确实是双工通信；


2、使用有名管道操作函数封装如下接口，简化有名管道操作流程：
    xxx   fifo_read(xx,xx,xx,xx); ===>该函数可以完成指定有名管道
									  的读操作
	xxx   fifo_write(xx,xx,xx,xx); ===》可以完成指定有名管道的写
										操作；

3、使用任意管道完成进程间文件传送；


4、使用任意管道完成 系统命令的结果捕获，比如
   在进程1 中执行  ls -l 命令将该命令的结果以管道形式发送给进程2





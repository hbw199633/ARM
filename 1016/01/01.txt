《UNIX 高级编程》
	IO开发
	并发程序
	网络开发
	c++和qt 

io:  input  output

io 设备：
	输入设备： 键盘终端 ...  ===》默认标准输入
	输出设备： 显示器终端 ... ===》默认标准输出


	标准输入设备：会阻塞等待；


io 分层：

文件io: ===>基于操作系统对外提供的一组系统调用接口函数
		===> man  2  xxx  查看
		===>安全性  高效率  同一接口

标准io： ===>基于文件io的一组对外提供功能的c库函数
	     ====>man 3 xxx  查看
		 ====>可移植  带缓存 高效率


标准io：===>stdio.h ===>/usr/include/stdio.h  ?


1、标准io缓存机制====>行缓存  满缓存  不缓存
     行缓存：标准输出设备在输出的时候遇到'\n'会自动刷新
	 		 输出缓存区数据。

		输出对象： 标准输出设备  == stdout
		输出方式： 标准io库函数  == printf  fprintf
		输出效果： 有'\n'刷新，没有则缓存。
	
	缓存区在程序正常结束的时候会自动刷新。

	满缓存： 当缓存区数据填满的时候，自动刷新缓存区。

			 默认的标准输出满缓存是 1024 字节
			 普通文件的默认满缓存是 4096 字节

	 如果需要在非满缓存时候刷新缓存区可以使用
	 fflush(NULL)函数强制刷新缓存区；

	 不缓存： 在输出的时候，没有缓存区缓存数据直接输出。
	
int  fprintf(FILE *stream, const char *format, ...);
功能：函数可以将格式化的数据输出到指定的stream流对象上。
参数：stream 文件流指针，是一个文件对象。
			 == stdin ===>默认的标准输入流对象 不能在fprintf使用
			 == stdout===>默认的标准输出流对象 等价 printf
			 == stderr===>默认的错误输出流对象 会不缓存输出
			 == fp    ===>fp 对应的文件流对象

	  format ... 完全类似printf的操作使用。
返回值：成功 0
		失败 -1；

	操作的对象： stderr
	操作的方式： fprintf
	操作的结果： 不缓存直接输出


	scanf() 是 fscanf() 的特殊形式，要求第一个参数是stdin
	printf()是 fprintf() 的特殊形式，要求第一个参数是stdout
	只是为了方便使用默认将scanf 和 printf 默认使用标准输入输出设备
	而fsanf和fprintf 可以指定输入输出设备。


3、标准输出设备的刷新方式：
	3.1   默认的行缓存刷新
	3.2   默认的满缓存刷新
	3.3   强制函数刷新 fflush()
	3.4   输出之后有输入则自动刷新；


===========================================================================


2、标准io文件流指针 ===》FILE * stream = xxxx;
						  int * pa   = &a;
	文件流分类：
		ascii 流 == 文本流 ==》人可直接识别并处理
		二进制流  ===》人不可直接识别需要再次加工处理

	FILE 类型：===》操作框架类似读书
		找到并打开文件 ===》读写文件 ==》 关闭归还文件
	
	linux 设计哲学之一： 一切皆为文件

	linux 文件标准操作框架：
		文件打开  ===》文件操作  ===》文件关闭
	  fopen()===> fgetc()/fputc() ==>fclose()
	  =====>12标准io库函数
		
3、标准io库函数

	3.1 fopen ==>fdopen===>freopen =====》家族函数

	FILE *fopen(const char *path, const char *mode);
	功能：函数可以指定的mode方式打开指定路径+名称的文件；
	参数：path 要打开的文件路径+名称；
		  mode 要打开的文件读写方式，可以有如下6种模式
		  	   r  只读  文件必须存在
			   r+ 读写  文件必须存在
			   w  只写  创建  清空
			   w+ 读写  创建  清空
			   a  只写  创建  追加
			   a+ 读写  创建  追加
			   以上6种方式任选其一。
	返回值：成功 FILE * 文件流指针，指向打开的文件
		    失败 NULL；

	3.2 要验证文件是否可以读写，必须查看文件读写方式：

		文件都写操作有如下四种方式：
		单字符读写： fgetc()/fputc()     getchar()/putchar()
		字符串读写： fgets()/fputs()	 gets()/puts()
		二进制读写： fread()/fwrite()
		格式化读写:  fscanf()/fprintf()  scanf()/printf()



	3.2.1 单字符读写：
	int fgetc(FILE *stream);   ///读操作
	 功能：函数可以从指定的文件流中获取一个字符并返回。
	 参数：stream 已经打开的文件流指针
	 返回值：成功 获取到的文件中字符
	 		 文件结尾 EOF == -1
	 		 失败 -1

	 int fputc(int c, FILE *stream); ///写操作
	 功能：该函数可以将指定的一个字符写入到目标文件流中
	 参数：c 要写入文件的字符
	 	   stream 要写入的文件流
	返回值：成功 写入的文件字符
			失败 -1；

0、使用以上文件都写操作函数验证文件打开时候的6种模式之间的差别。



1、问题:fgetc: Success
	fputc和fgetc 在操作的时候要考虑文件内容是否
	在缓存区中，而不是在文件中。


2、fopen 的返回值，fp每次不一样，原因是栈区变量
				   *fp 每次一样，原因是文件没变


3、如何编写代码验证普通文件的缓存区大小是4096字节；
	===>file_buff.c


4、w方式打开文件写一个字符，再读无效。
	原因： 缓存区    文件指针自动向后移动



3.3  关闭文件流
int fclose(FILE *fp);
功能：关闭指定的已经打开的文件流
参数：fp 要关闭的文件流对象
返回值：成功  0
		失败 -1
注意:同一个文件不能反复关闭。
     一个打开的文件必须关闭否则内存泄漏。
	 

5 、思考题： fgetc和fputc的单字符处理函数与getchar和putchar单字符
		     处理函数的关系是什么样的 ？




fgetc()  ===> getchar()
	===>getchar(） 默认从标准输入获取一个字符
	===>fgetc()    从指定的文件流获取一个字符
	===>stdin == 标准输入流，fgetc(stream)
	====>getchar()  ==  fgetc(stdin);
	====>fgetc() 可以从标准输入(stdin)获取数据
				也可以从指定的文件流(fp)获取数据
				适用范围比getchar() 大。
	====>getchar()  == getc()  ==  fgetc();


fputc()  ===> putchar()
	===>putchar()  默认从标准输出打印一个字符
	===>fputc()    向指定的文件流输出一个字符
	===>stdout == 标准输出流  == fputc(c,stdout)

	putchar()== putc() == fputc()


作业：使用标准io的常规操作函数完成以下程序；

1、 统计指定文件中数字和字符的个数并将结果打印输出。
	比如: ./a.out  1.txt 
	 1.txt 中字符 3245 个
	 1.txt 中数字 2345 个

2、将任意两个指定的文件完成拷贝功能：
	比如： ./a.out  a.txt b.txt 
	 把a.txt的内容拷贝到b.txt 中。

3、任意指定两个文件测试文件是否相等，如果不相等则
   输出不同部分。
    比如  ./a.out  a.txt  b.txt
	文件一样

	文件不一样，不同部分：
	a.txt xxxx
	b.txt xxxx  部分不一样

4、任意指定一个文件，将该文件中的代码行统计出来
   并将空白行去掉。
   比如： ./a.out  fgetc.c 

   代码行： xxx 行
   空白行;  xxx 行
  // 新文件： xxx.c




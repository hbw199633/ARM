多进程编程：

程序概念： 程序 = 数据结构 + 算法 ；资源与代码文件的有序集合；
进程概念： 进程是一个抽象实体，它是程序的一次执行过程；

进程与程序的区别：
1、进程是动态的，而程序是静态的。
2、进程运行在内存中，而程序存储在磁盘等存储介质上。
3、进程有唯一识别码 pid，程序的唯一识别码 inode。

进程和程序的分类：
1、程序的分类： 可执行程序  不可执行程序
2、进程的分类： 交互式进程  批处理进程  守护进程


进程的状态：
	运行态  等待态(可中断，不可中断)  停止态   僵尸态

验证进程的状态： ps  aux  ===> STAT 列
  ===>S  可中断的等待态
  ===>R  运行态
  ===>T  停止态
  ===>Z  僵尸态
  ===>D  不可中断的等待态

  ===>s 会话组长
  ===>N 低优先级
  ===>< 高优先级
  ===>l 多线程
  ===>+ 前台运行

进程的前后台控制：

./a.out  默认是前台运行，终端归当前程序控制。
./a.out & 将程序启动并转为后台执行。

如果要将运行的进程调整其前后台状态用如下命令：
1、jobs 命令查看当前终端中是否有后台进程执行；
	jobs -l  ===》可以当前终端的后台进程任务列表；

2、fg/bg 命令可以调整其前后台。
	fg  调整到前台,必须至少有一个后台程序在运行；
	bg  调整到后台，必须将当前终端脱离开并执行该命令，
		一般是先挂起在执行。


./a.out 
ctrl+z
bg

./c.out &
fg
注意事项：jobs  fg  bg 必须在同一终端操作。

如果一个终端中同时有多个任务在后台执行，需要将其中
指定任务调整到前台执行，则使用  fg 任务号 ===》[num]
[]的任务号后的+ 表示默认调度的进程。


进程控制命令： kill 命令 ====》发送信号命令

格式： kill -num pid
	  num  ===>kill -l 的数字编号也可以是宏名称
	  pid  ===>目标进程的pid号 可以通过ps命令查看

eg：  kill -9  32637

kill -19 xxx ===>停止进程 == ctrl+z   == kill  -SIGSTOP XXX
kill -18 xxx ===>继续运行停止进程     == kill  -SIGCONT XXX
kill -2  xxx ===>杀死进程 == ctrl + c
kill -3  xxx ===>杀死进程 == ctrl + \
kill  xxx  == kill -15 xxx ===>15信号是默认发送的信号
			 
注意：很多信号在停止状态可能会缓存信号。

================================================================
多进程编程函数： ===》fork函数

#include <unistd.h>

pid_t fork(void);
功能：该函数可以动态的生成一个同名子进程。
	  父子进程具有相同的逻辑和空间，类似于克隆程序。
	  但是父子进程执行的位置不同，子进程永远从fork函数之后执行。
	  如果要区分父子进程的执行逻辑，可以根据函数返回值来判断
	  约定 fork返回值为0 的是子进程执行逻辑
		   fork返回值>0  的是父亲进程执行逻辑


参数：无
返回值：
		大于0   表示子进程pid号
		等于0   表示子进程
		小于0   表示异常


思考题：
1、如何验证子进程永远从fork之后执行
2、如何验证父子进程有相同的逻辑和空间




pid_t getpid(void);
功能： 该函数可以获取当前进程自身的pid号
返回值：就是当前进程pid号

pid_t getppid(void);
功能：该函数可以获取当前进程的父进程的pid号
返回值：就是父进程pid号



笔试题：
	如果有两个连续fork函数执行，问会生成几个子进程？
	如果以人类家族图谱形式表示，有几个父进程？
	有几个子进程，几个兄弟进程，几个孙子进程？


练习题：
	如何使用fork函数动态生成10个子进程并让每个子进程
	执行不同的业务逻辑。


/*
	int test(int i)
	{
		switch(i)
		{
			case 0:  printf("0");break;
			case 1:  printf("1");break;
			case 2:  printf("2");break;
			case 3:  printf("3");break;
			case 4:  printf("4");break;
			。。。。
		}
	}
	int i = 0;
	for(i=0;i<10;i++)
	{
		pid = fork();
		if(pid == 0)
		{
			test(i);
			while(1);
		}
	}
	while(1)
	{
		sleep(1);
	}

*/



多进程的控制：

1、进程的退出
   return 关键字：在main函数中，表示进程结束。
				  在非main函数中，表示当前函数结束调用。

   1.1 在父子进程中都可以使用return关键字结束进程。

   1.2 exit函数
   #include <stdlib.h>

   void exit(int status);
   功能：使进程正常终止
   参数：status 进程结束时候的状态，用于返回进程调用者
   返回值：无

   1.3 _exit函数
   #include <unistd.h>

   void _exit(int status);
   功能：类似exit函数可以使进程正常结束。

   exit和_exit函数的区别，exit结束时候会自动刷新缓存区
						 _exit结束时候不会刷新缓存区

   僵尸进程：父子进程创建后，子进程退出
							 父进程运行
							 子进程变为僵尸进程
			 判断依据： ps aux ==>STAT 列为 Z

   孤儿进程：父子进程创建后，父亲进程退出
						     子进程运行
							 子进程变为孤儿进程

			 判断依据： ps -ef ===>PPID 列为 1


2、进程的回收  ===》避免僵尸进程和回收pid号

	2.1  wait 函数回收
	#include <sys/types.h>
	#include <sys/wait.h>

	pid_t wait(int *status);
	功能：该函数可以阻塞等待并回收任意子进程退出的资源。
	      一次该函数执行只能回收一个子进程的资源。
		  该函数只能有创建者进程调用，否则无效。
	参数：status 回收的子进程返回的状态，如果不关注
	      子进程的返回值，则用NULL表示，如果要关注
		  子进程的返回值，则用WEXITSTATUS获取返回值。
	返回值：成功 回收的子进程pid
			失败 -1

思考题：
1、wait 回收的资源能不能是字符串 ？   不能直接返回，但是可以间接返回。
2、wait 函数能不能指定回收进程资源？  不能直接回收，但是可以编程实现。



	2.2  waitpid函数回收

作业：
	使用fork函数创建一个父子进程程序，要求如下：
	父进程提示用户任意输入，并将用户输入写入指定文件
	子进程动态检测文件内容并将文件内容依次输出到屏幕
	当输入"quit"的时候，父子进程退出，不能有孤儿和僵尸进程出现。


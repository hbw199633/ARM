网络协议分析：===》《tcp/ip详解》卷1

应用层

传输层   TCP/UDP
网络层	 IP
物理层   MAC

1、物理链路层协议分析：总长度 = 14 + 4 以太网头部
	
	14字节：前 6 字节 是目的MAC地址   *****
			中 6 字节 是源MAC地址     *****
			后 2 字节 是上层协议类型
					  0x0800 IP协议
					  0x0806 ARP协议

			边界 4字节 校验位；

2、网络层 ===》ip层==》总长度 20字节长度

	第一字节： 前4bit位  表示当前网络协议版本号；
					4 ==》ipv4
					6 ==》ipv6
			   后4bit位  表示当前协议头部长度；
					 5 = 4*5 = 20 字节

	第二字节： TOS 服务质量 ===》1字节8bit位
			   前3bit位 表示优先级
			   中4bit位 表示 最小延迟 最大吞吐 最高可靠性 最小费用
			   后1bit位 暂时未用，预留

	第三、四字节： 表示数据总长度，2字节表示的范围：0 ～ 65535 字节
			   实际传送数据不是最大值，而是MTU == 1500字节

	第五、六字节： 编码格式

	第七字节： 前3 bit位： 表示数据传送控制方式，0x02 不分片

	第八字节+七字节的后5bit位： 片内偏移量

	第九字节： TTL 生存时间   linux 64   unix 256  window 128 
	第十字节： 上层协议类型， 0x06  tcp  0x11 udp 
	第十一、十二字节： 头部校验位

	第13 14 15 16 字节：源ip地址   ******
	第17 18 19 20 字节：目标ip地址 ******





3、传输层：
	3.1 TCP协议 ===>总长度 20字节
			第1、2 字节： 源地址端口   *****
			第3、4 字节： 目标地址端口 *****
				端口范围： 0 - 65535
			第5 6 7 8字节： 请求序列号
			第9 10 11 12字节：响应序列号

			第13字节 前4bit 头部长度
					 后4bit 暂时未用的预留字段
			第14字节 TCP flags ===》通信标志位
			            S  SYN  请求标志
						A  ACK  应答标志
						F  FIN  结束标志
						R  REST 重置标志
						P  push 发送数据标志
						U  urgent 紧急指针
			第15 16字节 滑动窗口
			第17 18 字节 tcp协议头部校验位
			第19 20 字节 选项是否使用扩展字段；

	3.2 UDP协议  ===》总长度 8 字节：
		前2 字节  源地址端口
		中2 字节  目的地址端口
		  2 字节  数据长度
		  2 字节  校验位

MTU 最大值 65535  《=== 2字节长度
	最小值 46     《=== 14+4 + 20 + 8字节长度
	默认值 1500   《网络实际传送的有效数据长度

练习：
	使用抓包工具获取数据并验证如上协议的分层内容是否正确。

==============================================================


广播/组播/域内套接字


广播通信 ===》基于UDP协议实现；

广播特征：	
	1、必须有一个发送数据的源端，能发送广播；===》UDP client
	2、必须有一个接收数据的收端，能接收广播；===》UDP server

1、数据发送端:
	socket()===> sendto() ====>close();

	注意：以上流程如果要发送广播数据需要如下调整：
	1、发送的目的地址不在是具体的主机地址，而是本网段的广播地址 
	2、一般情况下不允许发送广播，所有发送端需要修改套接字允许广播；

	int on = 1;
	setsockopt(sockfd,SOL_SOCKET,SO_BROADCAST,&on,sizeof(on));



2、数据接收端：
	socket()===>bind()===>recvfrom()===>close();

	注意：为了接收端能正常获取数据，在服务器端开始bind的时候
		  要将bind的地址和端口设置为 广播地址和端口；


问题：
1、同桌之间互相编写发送和接收，互相用不同的端口广播，查看
   能否正常广播，接收端看是否能收到，广播的主机地址信息。

2、能不能有选择性的只接收部分人发送的广播，其他的忽略？
	不能选择性的接收但是可以选择性的输出。


原因：由于广播会导致网络风暴，所以默认不转发广播数据。


组播 ===》多播 ===》小范围广播
	====》组播有固定的组播地址：224.0.0.1 --- 239.255.255.255
	====》组播地址是固定地址，没有掩码；

	约定：
	224.0.0.1 ---->224.0.0.255   局部地址，实验室测试使用
	224.0.1.0 ---->238.255.255.255 私有地址，专门预留给组播地址使用
	239.0.0.1 ---> 239.255.255.255 管理地址，互联网上出现

	特例：
	224.0.0.1 ====》组播主机
	224.0.0.2 ====》组播路由器
	224.0.0.5 ====》组播ospf路由器
	224.0.0.9 ====》组播rip路由器
	....


组播的发送和接收：
1、组播的发送：
	socket()===>sendto() ===>close();

	注意：组播的时候不需要修改套机字，只需要发送给指定
		  的组播地址即可。
2、组播的接收：
	socket()===>bind()===>recvfrom()===>close();

	注意：要接收数据必须将当前主机加入到组播的地址组中
		  要在bind函数调用之前将该主机加入组播；
		  bind的地址也必须是组播地址；

	加入组播有如下流程：
	1、定义组播地址；
		struct ip_mreq  mreq;  ///linux/in.h
		mreq.imr_multiaddr.s_addr  = inet_addr("组播地址");
		mreq.imr_interface.s_addr  = inet_addr("当前主机ip地址");
		setsockopt(sockfd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&mreq,sizeof(mreq));

	2、在bind的时候要bind组播地址：

	   bind(sockfd,&myaddr,len);  原来的方式；

	   struct sockaddr_in muladdr;  组播的bind方式
	   muladdr.sin_family	= AF_INET;
	   muladdr.sin_port		= htons(xxxx);
	   muladdr.sin_addr.s_addr =inet_addr("组播ip地址");
	   bind(sockfd,&muladdr,len);


问题：
	1、非组播地址和端口上能不能收到数据？
	2、在接收端能不能看到组播的发送者地址？


练习题：
	使用组播或者广播，完成一个服务器的心跳检测，如果一个
	服务器3秒之后没有心跳包发送给调度器，则调度打印其ip地址；




=============================================================
网络通信 ===》基于不同主机之间的进程间通信；
		
		 ===》单机的进程间通信： 管道 信号  IPC ....

域内套接字：===>单机的进程间通信

1、TCP协议的域内套接字 ===》服务器程序和客户端程序的进程间通信；
	服务器程序：  a.out
	socket()==>bind()==>listen()==>accept()==>recv()==>close();

	客户端程序：  b.out
	socket()==>connect()==>send()===> close();

	注意：以上框架通用与网络程序和域内通信；
	但是如果要进行域内进程间通信有如下变更;

	1、socket()的参数有变更；
		网络： socket(AF_INET,SOCK_STREAM,0);
		域内： socket(AF_LOCAL,SOCK_STREAM,0);
			   socket(AF_UNIX,SOCK_STREAM,0);

	2、bind() 的参数有变更；
		网络： struct sockaddr_in  myaddr;
			   myaddr.sin.....

			   bind(sockfd,&myaddr,len);


	    域内： struct sockaddr_un  myaddr;
			   myaddr.sun_family		= AF_UNIX;
			   myaddr.sun_path			= "/mnt/abc";
				
			   bind(sockfd,&myaddr,len);
	3、connect() 的目的参数不在ip+port地址，
				而是类似与bind的sockaddr_un 的结构类型地址；

练习：
	设计两个独立程序，使用socket方式完成进程间通信
	并将一个二进制文件传送给对方；

	

2、UDP协议的域内套接字 ===>非常类似与tcp通信过程：

	服务器端：
	socket() ===>bind()====>recvfrom()====>close()

	客户端：
	socket() ===>sendto()===>close();

	修改的事项，与tcp的域内套机字修改位置相同；

练习：
	使用udp域内套接字方式完成，父子进程间通信，可以
	从父进程向子进程发送用户输入的信息；







